[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "BST623 Software Tools for Manuscript Development and Reproducible Research is a course at the University of Miami, offered by the Biostatistics program. This class is taught by professor, Dr.Â Raymond Balise. The course focus on the use of software tools for creating professional-quality manuscripts and conducting reproducible research. Whether youâ€™re an experienced researcher or just starting out, BST 623 will provide valuable skills and knowledge to use R for your research."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "Welcome to the BST623 R Programming resource page! This site provides a collection of functions commonly used in the BST623 class, making it easier for you to access and utilize R programming tools in your coursework. Whether youâ€™re a seasoned programmer or new to R, this page is designed to provide a comprehensive and user-friendly experience. Happy coding!"
  },
  {
    "objectID": "notes/Class4/pivot_wider.html",
    "href": "notes/Class4/pivot_wider.html",
    "title": "BST623 functions",
    "section": "",
    "text": "pivot_wider() is a thing.\n\n\n{.center}\n\n\n\nWhat it does\n\n\nDemo code\n\n\nUsefull stuff\n\nThere is function called pivot_wider() that will take long data and make it wider.\nI rarely use it. Know it exists. .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/dplyr::if_else.html",
    "href": "notes/Class4/dplyr::if_else.html",
    "title": "BST623 functions",
    "section": "",
    "text": "dplyr::if_else()\n.center[if_else(*check*, *true*, *false*)] + if_else() checks the truth of a logic check on a variable/vector and returns the true argument if it is true or the false argument if it is not true.\n\nlaryngectomy %>%\n  mutate(  # does the initial stage agree with final pathology staging?\n    path_result = if_else(int_stg != path_stg, \"Changed\", \"Same\")\n  ) %>%\n  select(int_stg, path_stg, path_result)\n\n\nThe logic check can involve any number of variables.\nif_else() is dangerous because unexpected values can be binned in the false level/group.\n\n\nNA\n\n\n\nWhat it does\nNA\n\n\nDemo code\nNA\n\n\nUsefull stuff\nNA\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/dplyr::pull.html",
    "href": "notes/Class4/dplyr::pull.html",
    "title": "BST623 functions",
    "section": "",
    "text": "dplyr::pull() makes a vector.\n\npull(tableName, variableName)\n\n\n\nWhat it does\nRarely, you will want to pull a column out of a data frame and save it as a vector. pull() is the only dplyr verb that does not return a tibble.\n\n\nDemo code\n\nyes_no_ND <- laryngectomy %>%\n  mutate(hadND = 2 - nk_dissection) %>%\n  pull(hadND)\n\n\n\nUsefull stuff\n.center[] .related-functions[]\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/dplyr::across.html",
    "href": "notes/Class4/dplyr::across.html",
    "title": "BST623 functions",
    "section": "",
    "text": "dplyr::across() with dplyr::mutate()\n\nacross(varaibles), function\n\n\n\nWhat it does\n\nThe across() function with mutate() does the same mutation to multiple variables.\n\n\n\nDemo code\n\nlaryngectomy %>%\n  # Convert categorical character variavbles to be factors.\n  mutate(\n    across(gender:sor, factor)\n  )\n\n\n\nUsefull stuff\n\nThe across() function is used with dplyr::summarise to apply the same summary statistics to many variables. .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/group_by.html",
    "href": "notes/Class4/group_by.html",
    "title": "BST623 functions",
    "section": "",
    "text": "group_by() \\(_1\\)\n\ngroup_by(tableName, groupingVariable)\n\n\n\nWhat it does\nBefore dplyr 1.1 to get groups you would tag the dataset as having a grouping variable:\n\n\nDemo code\n\nlaryngectomy |> \n  select(gender, length_fu) |> \n  `group_by(gender)` # marks the grouping variable\n\n\n\nâ”€â”€ Attaching packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse 1.3.2 â”€â”€\nâœ” ggplot2 3.4.1     âœ” purrr   1.0.1\nâœ” tibble  3.1.8     âœ” dplyr   1.1.0\nâœ” tidyr   1.3.0     âœ” stringr 1.5.0\nâœ” readr   2.1.4     âœ” forcats 1.0.0\nâ”€â”€ Conflicts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse_conflicts() â”€â”€\nâœ– dplyr::filter() masks stats::filter()\nâœ– dplyr::lag()    masks stats::lag()\n\n\n# A tibble: 123 Ã— 2\n# Groups:   gender [2]\n   gender length_fu\n    <dbl>     <dbl>\n 1      1       103\n 2      1       240\n 3      1        93\n 4      1       546\n 5      1       208\n 6      1       199\n 7      1       155\n 8      1       480\n 9      1        23\n10      1        48\n# â€¦ with 113 more rows\n\n\n\n\nUsefull stuff\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/typeof.html",
    "href": "notes/Class4/typeof.html",
    "title": "BST623 functions",
    "section": "",
    "text": "typeof()\n.small[ .center[typeof(*vector*)] .center[typeof(*dataset$variable*)] + The â€œtypeâ€ of an object helps determine what behaviors an object can do.\n+ You can not take the mean of a character variable. + These are the typical types that are used in datasets: .pull-left[ + int = â€œintegerâ€ for numbers without decimals + dbl = â€œdoubleâ€ for numbers with decimals + lgl = â€œlogicalâ€ for true/false + date = â€œdateâ€] .pull-right[ + chr = â€œcharacterâ€ for character string + fct = â€œfactorâ€ for categories that are not ordered + ord = â€œorderedâ€ for ordered categories]\n\ntypeof(pi)\ntypeof(R.version$nickname)\n\n\nOther â€œtypesâ€ are used to categorize functions and other complex objects.\nR also uses mode() to describe type. It groups â€œintegerâ€ and â€œdoubleâ€ as â€œnumericâ€. ]\n\n\nNA\n\n\n\nWhat it does\nNA\n\n\nDemo code\nNA\n\n\nUsefull stuff\nNA\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/count.html",
    "href": "notes/Class4/count.html",
    "title": "BST623 functions",
    "section": "",
    "text": "count()\n\ncount(table, variables)\n\n\n\nWhat it does\ndplyr can do fancy summary statistics but count() is quick, easy and useful for frequency counts:\n\n\nDemo code\n.pull-left-60[\n\nlaryngectomy |>\n  mutate(isMale = 2 - gender ) |>\n  mutate(sex = as.character(isMale)) |>\n  mutate(sex = fct_recode(sex,\n                          \"Female\" = \"0\",\n                          \"Male\" = \"1\")) |>\n  mutate(stage = fct_recode(as.character(int_stg),\n                          \"T1\" = \"1\",\n                          \"T2\" = \"2\",\n                          \"T3\" = \"3\",\n                          \"T4\" = \"4\",\n                          \"Unknown\" = \"5\")) |>\n  `count(sex, stage)` |>\n  arrange(sex, stage)  # this just sorts by sex then stage\n\n] .pull-right-36[\n\n\nâ”€â”€ Attaching packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse 1.3.2 â”€â”€\nâœ” ggplot2 3.4.1     âœ” purrr   1.0.1\nâœ” tibble  3.1.8     âœ” dplyr   1.1.0\nâœ” tidyr   1.3.0     âœ” stringr 1.5.0\nâœ” readr   2.1.4     âœ” forcats 1.0.0\nâ”€â”€ Conflicts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse_conflicts() â”€â”€\nâœ– dplyr::filter() masks stats::filter()\nâœ– dplyr::lag()    masks stats::lag()\n\n\n# A tibble: 9 Ã— 3\n  sex    stage       n\n  <fct>  <fct>   <int>\n1 Female T1          1\n2 Female T2          1\n3 Female T3          1\n4 Female Unknown     4\n5 Male   T1         53\n6 Male   T2         34\n7 Male   T3          8\n8 Male   T4          4\n9 Male   Unknown    17\n\n\n]\n\n\nUsefull stuff\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/tally.html",
    "href": "notes/Class4/tally.html",
    "title": "BST623 functions",
    "section": "",
    "text": "tally()\n\ntally(dataset, variable)\n\n\n\nWhat it does\nIt adds up the values:\n\n\nDemo code\n.pull-left-60[\n\nsexVars <- laryngectomy %>%\n  mutate(isMale = 2 - gender ) %>%\n  mutate(sex = as.character(isMale)) %>%\n  mutate(sex = fct_recode(sex,\n                          \"Female\" = \"0\",\n                          \"Male\" = \"1\"))\n  sexVars %>% `tally(gender)`  # adds up 1s and 2s\n  sexVars %>% `tally(isMale)`  # adds up 0s and 1s\n# sexVars %>% tally(sex)  # can't sum up \"Male\" and \"Female\"\n\n] .pull-right-36[\n\n\n\n]\n\n\nUsefull stuff\n??? This was a good trickâ€¦ r theTallyTable, eval = FALSE r theTallyTableOut, ref.label=â€œtheTallyTableâ€, echo=FALSE .related-functions[]\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/distinct.html",
    "href": "notes/Class4/distinct.html",
    "title": "BST623 functions",
    "section": "",
    "text": "distinct()\n\n\n{.center}\n\n\n\nWhat it does\n\ndistinct() shows unique values.\n\n\n\nDemo code\n.pull-left-60[ .blue[distinct](table, variables)\n\nlaryngectomy %>% distinct(gender)\nlaryngectomy %>% distinct(int_stg)\nlaryngectomy %>%\n  mutate(isMale = 2 - gender ) %>%\n  mutate(sex = as.character(isMale)) %>%\n  mutate(sex = fct_recode(sex,\n                          \"Female\" = \"0\",\n                          \"Male\" = \"1\")) %>%\n  mutate(stage = fct_recode(as.character(int_stg),\n                          \"T1\" = \"1\",\n                          \"T2\" = \"2\",\n                          \"T3\" = \"3\",\n                          \"T4\" = \"4\",\n                          \"Unknown\" = \"5\")) %>%\n  `distinct(sex, stage)` %>%\n  arrange(sex, stage)\n\n] .pull-right-36[.verysmall[\n\n\n\n]]\n\n\nUsefull stuff\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/summarize.html",
    "href": "notes/Class4/summarize.html",
    "title": "BST623 functions",
    "section": "",
    "text": "summarize() to make rows/records with statistics. \\(_1\\)\n\n\n.small[summarize(tableName, newName = aggregateFunction)\nsummarize(tableName, aSum = sum(a), anAvg = mean(b), theVar = var(b)){.center}\n\n\n\nWhat it does\n\nMake a new dataset with summary statistics\nUse it to take a vector and output a single number\nOnly keeps the new variables\nBase aggregate functions\n\nmin max mean median quantile sd var IQR diff length sum\n\ndplyr aggregate functions\n\nfirst last nth n n_distinct\n\n\n\n\nDemo code\n.pull-left-60[\n\nlaryngectomy %>%\n{{  summarize(theMinFU = min(length_fu),}}\n{{            theMeanFU = mean(length_fu),}}\n{{            theMaxFU = max(length_fu))}}\n\n] .pull-right-36[\n\n\n\n] ]\n\n\nUsefull stuff\n.related-functions[]\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/dplyr::mutate.html",
    "href": "notes/Class4/dplyr::mutate.html",
    "title": "BST623 functions",
    "section": "",
    "text": "dplyr::mutate()\n\nmutate(dataset, a_variable = something)\n\n\n\nWhat it does\n.small[ + Use mutate() to make a new variable or replace an existing one.]\n\n\nDemo code\n\nlibrary(palmerpenguins)\npenguins |>\n  dplyr::mutate(weight_lbs = body_mass_g * 0.0022046226)\n\n\n\nUsefull stuff\n.small[ + The details after the = determine the values for the variable. + if_else() and case_when() are often used for calculations. + mutate() can use commas to make/modify many variables.]\n\npalmerpenguins::penguins |> \n  mutate(\n    weight_lbs = body_mass_g * 0.0022046226`,`\n    is_male = if_else(sex == male, 1, 0)\n  )\n\n.small[ + dplyr::transmute() is like mutate but it only keeps the variables you create (or reference).]\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/dplyr::coalesce.html",
    "href": "notes/Class4/dplyr::coalesce.html",
    "title": "BST623 functions",
    "section": "",
    "text": "dplyr::coalesce()\n\ncoalesce(varaible(s))\n\n\n\nWhat it does\n\nThe coalesce() function chooses the first not-missing value from a set of variables.\n\n\n\nDemo code\n\nlaryngectomy %>%\n  # Get day of worst outcome: death, reoccurrence, visit, or huge negative number\n  mutate(\n    outcome_day = coalesce(death_fu, recur_fu, length_fu, -99999999)\n  )\n\n\n\nUsefull stuff\n\nIf you include a huge outlier as the last option, it will make it easy to spot missing values. .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/dplyr::case_when.html",
    "href": "notes/Class4/dplyr::case_when.html",
    "title": "BST623 functions",
    "section": "",
    "text": "dplyr::case_when()\n\n\n.small[case_when (check ~ response, â€¦, check ~ repsonse){.center}\n\n\n\nWhat it does\n\ncase_when does a series of logic checks, in the order listed, and assigns the response from the first check that is true.\n\n\n\nDemo code\n.pull-left[\n\nlaryngectomy %>%\n  mutate(\n    \\`Pathological Stage` =\n      case_when(\n        path_stg %in% c(1, 2) ~ \"Early\",\n        path_stg %in% c(3, 4) ~ \"Late\",\n        # If you didn't know this value existed...\n        # path_stg == 5 ~ \"Unknown\",\n        .default ~ \"*** PROBLEM ***\"\n      )\n  ) %>%\n  count(\\`Pathological Stage`)\n\n] .pull-right[\n\n\n\n]\n\n\nUsefull stuff\n\ncase_when() often uses TRUE as the last logic check. Because it is always true, it acts like â€œelseâ€ or â€œotherwiseâ€.\nUse case_when() instead of if_else() if there is any chance the data has unexpected values. ] .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/dplyr::transmute.html",
    "href": "notes/Class4/dplyr::transmute.html",
    "title": "BST623 functions",
    "section": "",
    "text": "dplyr::transmute()\n\nlaryngectomy %>% transmute(hadND = 2 - nk_dissection).demo-code[{r eval = FALSE}\nlaryngectomy %>% transmute(hadND = 2 - nk_dissection)\n{.center}\n\n\n\nWhat it does\ntransmute() is like dplyr::mutate() but it only keeps the variables referenced. Because it is picking what variables to keep, you can select other variables without manipulating them. .useful-stuff[]\n\nlaryngectomy %>%\n  transmute(\n    hadND = 2 - nk_dissection`,`\n    `nk_dissection`\n  )\n\n\n\nDemo code\nNA\n\n\nUsefull stuff\nNA\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/mutate.html",
    "href": "notes/Class4/mutate.html",
    "title": "BST623 functions",
    "section": "",
    "text": "mutate() for Errors and Secret Codes\n\nanalysis <- balise %>%\n  mutate(middle = if_else(middle == \"x\", NA_character_, middle)) %>%\n  mutate(births = if_else(births < 0, NA_real_, births))\nanalysis\n\nNotice the print method for black and white puts NA inside of <>. I prefer the print method used in the console.\n\nNA\n\n\n\nWhat it does\nNA\n\n\nDemo code\nNA\n\n\nUsefull stuff\nNA\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class2/%>%.html",
    "href": "notes/Class2/%>%.html",
    "title": "BST623 functions",
    "section": "",
    "text": "%>%\n\n\\(thing_1\\) %>%\n\\(thing_2\\) {.center}\n\n\n\nWhat it does\n\nThe symbol %>% is called a pipe. When describing a workflow, it is spoken as â€œthenâ€.\nIt sends the output from \\(thing_1\\) to the first argument of \\(thing_2\\).\n\n\n\nDemo code\n\nnrow(medicaldata::covid_testing) %>%\n  scales::comma() %>%\n  print()\n\n\n\nUsefull stuff\n\nMany functions can be connected in a pipeline.\nStart code after a pipe on a new line.\nIndent all lines of code two spaces after the first pipe. .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class2/R.Version.html",
    "href": "notes/Class2/R.Version.html",
    "title": "BST623 functions",
    "section": "",
    "text": "R.Version()\n\nR.Version()\n\n\n\nWhat it does\n\nR.Version() returns a list of details about the version of that is currently running.\n\n\n\nDemo code\n\nR.Version()\n\n\n\nUsefull stuff\n.center[R.version.string] + R.version.string is an easier to work with description of your version of R:\n\nR.version.string\n\n\nThis is useful for extracting the version of R for publications: stringr::word(R.version.string, 1, 3) .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class2/suppressMessages.html",
    "href": "notes/Class2/suppressMessages.html",
    "title": "BST623 functions",
    "section": "",
    "text": "suppressMessages()\n\nsuppressMessages(function)\n\n\n\nWhat it does\n\nThis will muffle messages produced by a chatty function.\n\n\n\nDemo code\n\nsuppressMessages(library(h2o))\n\n\n\nUsefull stuff\n\nIt may be clearer to write: library(*package*, quietly = TRUE).\nThis helps with packages that are chatty even when using the quietly = TRUE argument to library().\nThis prevents many messages from showing up in R Markdown output without suppressing other critical messages. .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class2/mean.html",
    "href": "notes/Class2/mean.html",
    "title": "BST623 functions",
    "section": "",
    "text": "mean()\n\nmean(vector, na.rm = value)\n\n\n\nWhat it does\n\nIt calculates an average.\nBy default it returns NA is any value is missing.\nYou normally use this on a typical numeric variable but it can be use for other types of data if it can convert them to numbers (like dates/times).\n\nYou can also calculate the average on a logical (TRUE/FALSE) variable to get the percent true. Remember: 1=TRUE/YES, 0=FALSE/NO in everything you do.\n\n\n\n\nDemo code\n.small[\n\nmean(mtcars$mpg)\n\n[1] 20.09062\n\nmean(TRUE)\n\n[1] 1\n\n\n]\n\n\nUsefull stuff\n.related-functions[]\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class2/knitr::opts_chunk$set.html",
    "href": "notes/Class2/knitr::opts_chunk$set.html",
    "title": "BST623 functions",
    "section": "",
    "text": "knitr::opts_chunk$set()\n\nknitr::opts_chunk$set(option = value)\n\n\n\nWhat it does\n\nThis command allows you to set the default behavior for code chunks when knitting\nFor example, this specifies that you want to always show code but never run it\n\n\n\nDemo code\n\nknitr::opts_chunk$set(echo = TRUE, eval = FALSE)\n\n\n\nUsefull stuff\n\nThis command belongs in the â€œsetupâ€ chunk at the top of an R Markdown script.\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class2/conflicted::conflicted_prefer.html",
    "href": "notes/Class2/conflicted::conflicted_prefer.html",
    "title": "BST623 functions",
    "section": "",
    "text": "conflicted::conflicted_prefer()\n\n\n.small[conflicted_prefer(â€œfunctionâ€, â€œwinning packageâ€, quiet = TRUE){.center}\n\n\n\nWhat it does\n\nThe conflicted packages complains when the same function name is used in multiple packages.\nUse conflicted_prefer() to specify which version should be used by default.\n\n\n\nDemo code\n\nconflict_prefer(\"filter\", \"dplyr\", quiet = TRUE)\n\n\n\nUsefull stuff\n\nYou can overwrite this default with package::function().\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class2/scales::comma.html",
    "href": "notes/Class2/scales::comma.html",
    "title": "BST623 functions",
    "section": "",
    "text": "scales::comma()\n\nscales::comma(number)\n\n\n\nWhat it does\n\nIt adds commas to number.\n\n\n\nDemo code\n\n\nUsefull stuff\n\nscales::comma(9001)\n\n\nThis is extremely useful when preparing R Markdown reports. .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class2/<-.html",
    "href": "notes/Class2/<-.html",
    "title": "BST623 functions",
    "section": "",
    "text": "<-\n\nthingy <- something\n\n\n\nWhat it does\n\nYou use <- to assign an object (e.g., thingy) a value (e.g., something).\nThe <- operator is pronounced â€œgetsâ€.\nIn other languages this would be an =.\n\n\n\nDemo code\n\neverything <- 42\n\n\n\nUsefull stuff\n\nYou can also use -> (e.g., something -> thingy) but it violates all style guides.\n\n\n\nCommon Problems\n\nUse an =, not <- , to assign values to an argument in a function call.\n\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class2/rUM::make_project\"\".html",
    "href": "notes/Class2/rUM::make_project\"\".html",
    "title": "BST623 functions",
    "section": "",
    "text": "rUM::make_project(\"\")\n\nmake_project(â€œlocationâ€)\n\n\n\nWhat it does\n\nThis copies the â€œshellâ€ for an academic paper into a folder/directory.\nFor example, this copies the rUM files into the current folder:\n\n\n\nDemo code\n\nrUM::make_project(\"./\")\n\n\n\nUsefull stuff\n\nIt is probably easier to use the New Project Wizard from the File menu and choose Research Project Template. .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class2/stringr::word.html",
    "href": "notes/Class2/stringr::word.html",
    "title": "BST623 functions",
    "section": "",
    "text": "stringr::word()\n\nword(sentence), start, stop*{.center}\n\n\n\nWhat it does\n\nUse this to extract words from a sentence.\n\n\n\nDemo code\n\nwisdom <- \"Caesar salad was created by an Italian in Mexico.\"\nstringr::word(wisdom, 7, 9)\n\n[1] \"Italian in Mexico.\"\n\n\n\n\nUsefull stuff\n\nThis is useful for extracting the version of R for publications: stringr::word(R.version.string, 1, 3) .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class2/nrow.html",
    "href": "notes/Class2/nrow.html",
    "title": "BST623 functions",
    "section": "",
    "text": "nrow()\n\nnrow(dataset)\n\n\n\nWhat it does\n\nnrow() reports the number of rows/records in a dataset (or matrix).\n\n\n\nDemo code\n\nnrow(mtcars)\n\n[1] 32\n\n\n\n\nUsefull stuff\n\nYou will likely use this with scales::comma() to include the number of observations in a dataset as part of a report.\n\n\nscales::comma(\n  nrow(medicaldata::covid_testing)\n)\n\n[1] \"15,524\"\n\n\n.related-functions[]\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class2/remotes::install_github.html",
    "href": "notes/Class2/remotes::install_github.html",
    "title": "BST623 functions",
    "section": "",
    "text": "remotes::install_github()\n\nremotes::install_github(author/package)\n\n\n\nWhat it does\n\nDownloads and install a package from from www.github.com.\n\n\n\nDemo code\n\nremotes::install_github(\"RaymondBalise/rUM\")\n\n\n\nUsefull stuff\n\nUse this release to get the latest bug fixes.\nIt checks to see if there is any new content before it downloads.\nYou will need tools to build packages.\n\nThese tools ship with Mac.\nOn Windows you will need to install Rtools .related-functions[]\n\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class2/paste0.html",
    "href": "notes/Class2/paste0.html",
    "title": "BST623 functions",
    "section": "",
    "text": "paste0()\n\npaste0(things)\n\n\n\nWhat it does\n.small[ + It pastes together character strings without adding spaces. + The paste0() function prints a slash before quotes.\n\n\nDemo code\n.pull-left[\n\npaste0(\"The cyberman\", \" cried.\")\n\n[1] \"The cyberman cried.\"\n\npaste0('The cyberman said \"error.\"')\n\n[1] \"The cyberman said \\\"error.\\\"\"\n\nwords <- \"Hi Mom\"\npaste0(\"Ray said \", '\"', words, '\".')\n\n[1] \"Ray said \\\"Hi Mom\\\".\"\n\n\n] .related-functions[]\n.pull-right[ + The .blue[paste()] function puts a space between words. + The .blue[glue::glue()] function is an excellent alternative.\n\nwords <- \"Hi Mom\"\nglue::glue('Ray said \"{words}\".')\n\nRay said \"Hi Mom\".\n\n\n] ] .common-problems[]\n\n\nUsefull stuff\nNA\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class2/options.html",
    "href": "notes/Class2/options.html",
    "title": "BST623 functions",
    "section": "",
    "text": "options()\n\n\n.small[options(option = value){.center}\n\n\n\nWhat it does\n\nThe options() function sets the global behavior used by R, including how numbers are printed/formatted.\n\nSome packages allow you to set default behavior.\n\nFor example, you can turn off messages about how summarise() function behaves in dplyr with this option:\n\n\n\n\nDemo code\n\noptions(dplyr.summarise.inform = FALSE)\n\n\n\nUsefull stuff\n.related-functions[]\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class2/cat.html",
    "href": "notes/Class2/cat.html",
    "title": "BST623 functions",
    "section": "",
    "text": "cat()\n\ncat(things)\n\n\n\nWhat it does\n.pull-left-60[ + cat() is simpler version of the paste() function. + It does not print the vector position, like print(). + It does not prints a slash before quotes.]\n\n\nDemo code\n.pull-right-36[\n\ncat(\"The cyberman\", \"cried.\")\n\nThe cyberman cried.\n\ncat('The cyberman said \"error.\"')\n\nThe cyberman said \"error.\"\n\nwords <- \"Hi Mom\"\ncat(\"Ray said \", '\"', words, '\".')\n\nRay said  \" Hi Mom \".\n\n\n]\n\n\nUsefull stuff\n\nThe glue::glue() is an excellent alternative.\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/table1::table1.html",
    "href": "notes/Class3/table1::table1.html",
    "title": "BST623 functions",
    "section": "",
    "text": "table1::table1()\n\ntable1(formula, dataset)\n\n\n\nWhat it does\n\ntable1() is an excellent tool for taking a quick look at a dataset.\n\n\n\nDemo code\n\ntable1::table1(~ alcgp + tobgp | agegp, data=esoph)\n\n\n\nUsefull stuff\n\nIt will make a simple table with a basic fomula ~ *variable* + *variable(s)*\nIt will make a table summarizing subgroups with a formula that includes a | *variable*\nThe gt package with gtsummary is more powerful (including p-values) but it requires more code. .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/dplyr::if_else.html",
    "href": "notes/Class3/dplyr::if_else.html",
    "title": "BST623 functions",
    "section": "",
    "text": "dplyr::if_else()\n\nif_else(check, true, false)\n\n\n\nWhat it does\n\nif_else() checks the truth of a logic check on a variable/vector and returns the true argument if it is true or the false argument otherwise.\n\n\n\nDemo code\n\nif_else(mtcars$am == 0, \"Automatic\", \"Manual\")\n\n\n\nUsefull stuff\n\nThe logic check can involve any number of variables.\nif_else() is often used with dplyr::mutate()\nif_else() is dangerous because unexpected values can be binned in the false level/group. .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/pillar::glimpse.html",
    "href": "notes/Class3/pillar::glimpse.html",
    "title": "BST623 functions",
    "section": "",
    "text": "pillar::glimpse()\n\n\n.small[glimpse(dataset){.center}\n\n\n\nWhat it does\n\nglimpse() is a convenient alternative to str() for when you want quick look at dataset.\nglimpse() shows the â€œtype ofâ€ each column of data. .pull-left[\nint = â€œintegerâ€ for numbers without decimals\ndbl = â€œdoubleâ€ for numbers with decimals\nlgl = â€œlogicalâ€ for true/false\ndate = â€œdateâ€] .pull-right[\nchr = â€œcharacterâ€ for character string\nfct = â€œfactorâ€ for categories that are not ordered\nord = â€œorderedâ€ for ordered categories ]\n\n\n\nDemo code\n.scroll-box-8[\n\npillar::glimpse(iris)\n\nRows: 150\nColumns: 5\n$ Sepal.Length <dbl> 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9, 5.4, 4.â€¦\n$ Sepal.Width  <dbl> 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1, 3.7, 3.â€¦\n$ Petal.Length <dbl> 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5, 1.5, 1.â€¦\n$ Petal.Width  <dbl> 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1, 0.2, 0.â€¦\n$ Species      <fct> setosa, setosa, setosa, setosa, setosa, setosa, setosa, sâ€¦\n\n\n]\n\n\nUsefull stuff\n\nglimpse() is in the pillar package but it automatically is loaded with either dplyr or tibble. ] .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/format.html",
    "href": "notes/Class3/format.html",
    "title": "BST623 functions",
    "section": "",
    "text": "format()\n\nformat(number(s), scientific=FALSE)\n\n\n\nWhat it does\n\nUse format() to display numbers and text many formats and alignment options.\n\n\n\nDemo code\n\nhuge <- 1000000000000000\nformat(huge, big.mark=\",\", scientific=FALSE)\n\n[1] \"1,000,000,000,000,000\"\n\n\n\n\nUsefull stuff\n\nformat() is useful for showing huge and tiny numbers without scientific notation.\nformat() can be use display aligned text. .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/noquote.html",
    "href": "notes/Class3/noquote.html",
    "title": "BST623 functions",
    "section": "",
    "text": "noquote()\n\nnoquote(text)\n\n\n\nWhat it does\n\nThe print() function prints without quotes. noquote() function prints without quotes.\n\n\n\nDemo code\n\nnoquote('The cyberman said \"error.\"')\n\n[1] The cyberman said \"error.\"\n\n\n\n\nUsefull stuff\n\nThis is similar to paste(text, quote = FALSE) but if you save a noquote object it will remember the object should not be quoted. .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/pipe.html",
    "href": "notes/Class3/pipe.html",
    "title": "BST623 functions",
    "section": "",
    "text": "|>\n\nthing |> thing\n\n\n\nWhat it does\n\nThe base R pipe, |>, is designed to pass an object into the first argument of another function.\n\n\n\nDemo code\n\nmtcars |> subset(cyl == 4) |> head()\n\n\n\nUsefull stuff\n\nThis pipe is faster than the magrittr pipe (i.e., %>%).\nIt can not redirect to any argument other than the first.\nIt is of limited use because many critical functions (e.g., lm() and plot()) do not take a dataset as the first argument.\n\n.related-functions[]\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/tibble::tribble.html",
    "href": "notes/Class3/tibble::tribble.html",
    "title": "BST623 functions",
    "section": "",
    "text": "tibble::tribble()\n.center[tribble(thing(s))] .small[ + The tribble() function let you enter rows of data.\n\nfam <-\n  tribble(\n    ~Name,     ~Species,\n    \"Raymond\", \"homo sapiens\",\n    \"Snowy\",   \"canis lupus familiaris\",\n    \"Crab\",    \"anomuran decapod crustaceans\"\n  )\n\n\nRemember the names have a + ~ prefix.\nEvery element (except the last) is followed by a comma.\nYou can use spacing to make the code easier to read. See â€œfun facts on the tibble slide. ]\n\n\nNA\n\n\n\nWhat it does\nNA\n\n\nDemo code\nNA\n\n\nUsefull stuff\nNA\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/select.html",
    "href": "notes/Class3/select.html",
    "title": "BST623 functions",
    "section": "",
    "text": "select()â€™s Helper Functions\n\nstarts_with(\"X\"): every name that starts with â€œXâ€\nends_with(\"X\"): every name that ends with â€œXâ€\ncontains(\"X\"): every name that contains â€œXâ€\nmatches(\"X\"): every name that matches â€œXâ€, where â€œXâ€ can be a regular expression\nnum_range(\"x\", 1:5): the variables named x01, x02, x03, x04 and x05\none_of(x): every name that appears in x, which should be a character vector\n\n\nlibrary(lr4ds)\nlaryngectomy %>%\n   select(`ends_with(\"_fu\")`) %>%\n   head(n = 2)  # only keep first two records (to fit on the slide)\n\n\n\n\n\nNA\n\n\n\nWhat it does\nNA\n\n\nDemo code\nNA\n\n\nUsefull stuff\nNA\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/dput.html",
    "href": "notes/Class3/dput.html",
    "title": "BST623 functions",
    "section": "",
    "text": "dput()\n\ndput(thingy)\n\n\n\nWhat it does\n\nPrint a text version of any object in the console (by default).\n\n\n\nDemo code\n\ndput(names(iris))\n\nc(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\", \n\"Species\")\n\n\n\n\nUsefull stuff\n\nIt is very convenient if you want to get a set of variable names for later processing. .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/table.html",
    "href": "notes/Class3/table.html",
    "title": "BST623 functions",
    "section": "",
    "text": "table()\n\ntable(vector(s))\n\n\n\nWhat it does\n.small[ + Make a summary table of a vector or a pair of vectors.\n\n\nDemo code\n\ntable(iris$Species)\n\n\n    setosa versicolor  virginica \n        50         50         50 \n\ntable(mtcars$cyl, mtcars$vs)\n\n   \n     0  1\n  4  1 10\n  6  3  4\n  8 14  0\n\n\n\n\nUsefull stuff\n\ntable() does not have a dataset option and it does not label well.\nIt is well suited for quick checks while debugging. ] .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/rep.html",
    "href": "notes/Class3/rep.html",
    "title": "BST623 functions",
    "section": "",
    "text": "rep()\n\nrep(value, #)\n\n\n\nWhat it does\n\nThe rep() function is used to repeat something.\n\n\n\nDemo code\n\nrep(\"Cup of Coffee\", 3)\nfam <-\n  tibble(\n    name_first = c(\"Raymond\", \"Lori\", \"Mary\", \"Andrew\", \"Ella\", \"Snowy\", \"Mia\", \"Crab\"),\n    name_last = c(rep(\"Balise\", 4), \"Johnson\", rep(\"Balise\", 3)),\n    species = c(rep(\"human\", 5), c(\"Canis lupus familiaris\", 2), \"anomuran decapod crustaceans\")\n  )\n\n\n\nUsefull stuff\n\nWhen creating a new dataset, the base R data.frame function will try to repeat (recycle) values if a variable/column is â€œshortâ€ (i.e., a value is missing). This can be problematic. The tibble function does not automatically recycle values. Use rep() rather that repeatedly typing the same value.\nrep() function can do complex repeating patters. rep(c(â€œfunâ€, â€œadoâ€, â€œtreeâ€), c(1, 2, 3)) .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/tidyr::drop_na.html",
    "href": "notes/Class3/tidyr::drop_na.html",
    "title": "BST623 functions",
    "section": "",
    "text": "tidyr::drop_na()\n.center[drop_na(*dataset*)] + Use tidyr::drop_na() to create a dataset with â€œcomplete casesâ€ (i.e., only keep people with complete data).\n\nlaryngectomy %>%\n  drop_na()\n\n\nThere is no easy dplyr function to find records without any missing data.\nIf you love to type you can write a dplyr::filter() function call to check for no missing data in all variables.\n\n\nNA\n\n\n\nWhat it does\nNA\n\n\nDemo code\nNA\n\n\nUsefull stuff\nNA\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/dplyr::mutate.html",
    "href": "notes/Class3/dplyr::mutate.html",
    "title": "BST623 functions",
    "section": "",
    "text": "dplyr::mutate()\n\nmutate(data, variable = stuff)\n\n\n\nWhat it does\n.small[ + mutate() is used to create and manipulate variables in the tidyverse ecosystem.\n\n\nDemo code\n\nmtcars %>%\n  mutate(Transmition = if_else(am == 0, \"Automatic\", \"Manual\"),\n         Transmition = factor(Transmition))\n\n\n\nUsefull stuff\n\nYou can have any number of comma delimited mutations in one function call.\nThe if_else() and case_when() functions are particularly useful with mutate().\nmutate() can apply the same mutation to multiple values if it is mixed with the across() function: mutate(across(c(vs, am), factor)).\n\n\nmtcars %>%\n  mutate(\n    across(c(vs, am), factor)\n  )\n\n] .related-functions[]\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/slice_sample.html",
    "href": "notes/Class3/slice_sample.html",
    "title": "BST623 functions",
    "section": "",
    "text": "slice_sample() grabs a few records.\nIf you have a lot of data, you can easily use slice_sample() with the n = or prop = arguments to take a sample for doing preliminary work. Be sure to use the base R set.seed() function before slice_sample() to specify which set of random records to select.\n\nset.seed(123)\nlaryngectomy %>%\n  select(age, gender, recur_site, trt_mod, int_stg, recur_stg) %>%\n  slice_sample(prop = .05)  # a random 5% of the data\n\n\nNA\n\n\n\nWhat it does\nNA\n\n\nDemo code\nNA\n\n\nUsefull stuff\nNA\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/str.html",
    "href": "notes/Class3/str.html",
    "title": "BST623 functions",
    "section": "",
    "text": "str()\n\nstr(thingy)\n\n\n\nWhat it does\n.small[ + Useful you to see information on the structure of any. It is somewhat useful for datasets.\n\n\nDemo code\n\nstr(iris)\n\n'data.frame':   150 obs. of  5 variables:\n $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...\n $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...\n $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...\n $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...\n $ Species     : Factor w/ 3 levels \"setosa\",\"versicolor\",..: 1 1 1 1 1 1 1 1 1 1 ...\n\n\n\n\nUsefull stuff\n\nThe output an be voluminous.\n\n\nstr(\n  lm(height~weight, data= women)\n)\n\n\nglimpse() is often more useful. ] .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/dplyr::filter.html",
    "href": "notes/Class3/dplyr::filter.html",
    "title": "BST623 functions",
    "section": "",
    "text": "dplyr::filter()\n.center[filter(tableName, logical test)] + Use filter() to pick rows/records. + Inside the () you put a logic check. + filter() keeps rows/records where the logic check is true.\n\nlaryngectomy %>%\n  filter(death == 1)  # the people who died\nlaryngectomy %>%\n  filter(is.na(pathology))  # people missing pathology\nlaryngectomy %>%\n  filter(!is.na(pathology))  # people not missing pathology\nlaryngectomy %>%\n  filter(pathology %in% c(1, 2)) # people with values of 1 or 2\n\n\nNA\n\n\n\nWhat it does\nNA\n\n\nDemo code\nNA\n\n\nUsefull stuff\nNA\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/names.html",
    "href": "notes/Class3/names.html",
    "title": "BST623 functions",
    "section": "",
    "text": "#names()\n\nnames(thingy)\n\n\nWhat it does\n\nIf you want a print the variable names in a dataset.\n\n\n\nDemo code\n\nnames(iris)\n\n[1] \"Sepal.Length\" \"Sepal.Width\"  \"Petal.Length\" \"Petal.Width\"  \"Species\"     \n\n\n\n\nUsefull stuff\n.related-functions[] + I frequently use it with dput()\n\ndput(names(iris))\n\nc(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\", \n\"Species\")\n\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/?.html",
    "href": "notes/Class3/?.html",
    "title": "BST623 functions",
    "section": "",
    "text": "?\n\n?thingy\n\n\n\nWhat it does\n\nOpen the help file for an object that you donâ€™t understand. It is useful to find variable definitions for some datasets and some function argument details.\n\n\n\nDemo code\n\n?women\n\n\n\nUsefull stuff\n\nNote: There is no help file for for men. ?men .\n\n\n?men\n\nNo documentation for 'men' in specified packages and libraries:\nyou could try '??men'\n\n\n.related-functions[] + ?? does a broader search in the local documentation.\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/c.html",
    "href": "notes/Class3/c.html",
    "title": "BST623 functions",
    "section": "",
    "text": "c() is smart! \\(_1\\)\n\nRemember from â€œtopic 1â€ that R pays attention to the class/type objects.\nc() will notice if the parts that you are combining are numbers or text and it will make the object the correct class/type. .pull-left-36[\n\n\nages <- c(17, 18, 40, 39)\nclass(ages)\n\n[1] \"numeric\"\n\nages\n\n[1] 17 18 40 39\n\n\n]  â€“ .pull-right-60[\n\nages <- c(\"seventeen\", \"eighteen\", \"forty\", \"thirty nine\")\nclass(ages)\n\n[1] \"character\"\n\nages\n\n[1] \"seventeen\"   \"eighteen\"    \"forty\"       \"thirty nine\"\n\n\n]\n\nNA\n\n\n\nWhat it does\nNA\n\n\nDemo code\nNA\n\n\nUsefull stuff\nNA\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/dplyr::select.html",
    "href": "notes/Class3/dplyr::select.html",
    "title": "BST623 functions",
    "section": "",
    "text": "dplyr::select()\n.center[select(*dataset*, *variables*)] + Use select() to choose variables to keep in a new dataset.\n\nlaryngectomy %>%\n  `select(age, gender, death_fu)`\ncomplications <- laryngectomy %>%\n   select(complications`:`comp_2plus)\n\n\nselect() does not do autocomplete.\nYou can refer to variables by position number. The first variable is 1. ğŸ¤¢.\nYou can .red[remove/exclude] unwanted variables with a -:\n\n\nwithoutComplicationVars <- laryngectomy %>%\n   select(`-`(complications:comp_2plus))\n\n\nNA\n\n\n\nWhat it does\nNA\n\n\nDemo code\nNA\n\n\nUsefull stuff\nNA\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/dplyr::rename.html",
    "href": "notes/Class3/dplyr::rename.html",
    "title": "BST623 functions",
    "section": "",
    "text": "dplyr::rename()\nYou can easily tweak a variableâ€™s name with: .center[rename(tableName, newName = oldName)] .small[\n\nlaryngectomy %>%\n  rename(sex = gender)  # from gender to sex\n\n]\n\nNA\n\n\n\nWhat it does\nNA\n\n\nDemo code\nNA\n\n\nUsefull stuff\nNA\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/tibble::tibble.html",
    "href": "notes/Class3/tibble::tibble.html",
    "title": "BST623 functions",
    "section": "",
    "text": "tibble::tibble()\n.center[tibble(thing(s))] .small[ + The tibble() function will convert base R vectors or a data.frame into a tidyverse tibble\n\nmtcars <- as_tibble(mtcars)\nfam <-\n  tibble(\n    \\`First Name` = c(\"Raymond\", \"Lori\", \"Mary\", \"Andrew\", \"Ella\", \"Snowy\", \"Mia\", \"Crab\"),\n    \\`Last Name` = c(rep(\"Balise\", 4), \"Johnson\", rep(\"Balise\", 3)),\n    species = c(rep(\"h. sapiens\", 5), c(\"canis lupus familiaris\", 2), \"anomuran decapod crustaceans\")\n  )\n\n\ntibbles have a useful print method.\ntibbles do not use row names. Convert row names to a variable with rownames_to_column()\nThey do not accept partial matching (i.e., fam$F does not work).\ntibbles do not automatically change data.\n\nCharacter variables do not become factors!\nColumn names are not converted to base names (e.g.Â spaces are allowed). ]\n\n\n\nNA\n\n\n\nWhat it does\nNA\n\n\nDemo code\nNA\n\n\nUsefull stuff\nNA\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class1/%>%.html",
    "href": "notes/Class1/%>%.html",
    "title": "BST623 functions",
    "section": "",
    "text": "%>% from the magrittr Package\n\n\\(thing_1\\) %>%\n\\(thing_2\\) {.center}\n\n\n\nWhat it does\n\nThe symbol %>% is called a pipe. When describing a workflow, it is spoken as â€œthenâ€.\nIt normally sends the output from \\(thing_1\\) to the first argument of \\(thing_2\\).\n\n\n\nDemo code\n\nmtcars %>%\n  filter(mpg == 30.4)\n\n\n\nUsefull stuff\n\nMany functions can be connected in a pipeline.\nStart code after a pipe on a new line.\nIndent all lines of code two spaces after the first pipe.\n\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class1/dplyr::pull.html",
    "href": "notes/Class1/dplyr::pull.html",
    "title": "BST623 functions",
    "section": "",
    "text": "dplyr::pull()\n\npull(dataset, variable)\n\n\n\nWhat it does\n\nThe pull() is used to copy of a variable out of a dataset into a new object.\n\n\n\nDemo code\n\npull(mtcars, mpg)\n\n\n\nUsefull stuff\n\nWhen it is used with the filter() function, pull() can be used to extract a single value from a dataset. This is useful when you need to extract a number, like an odds ratio or a p-value, for a report.\npull() is the only dplyr function that does not return a tibble.\n\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class1/class.html",
    "href": "notes/Class1/class.html",
    "title": "BST623 functions",
    "section": "",
    "text": "class()\n\nclass(thingy)\n\n\n\nWhat it does\nIf you are not sure what something is, you can check its class by typing using the class() function in the console windowpane.\n\n\nDemo code\n\nclass(iris)\n\n\n\nUsefull stuff\n.pull-left[.center[]] .pull-right[.center[]]\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class1/rm.html",
    "href": "notes/Class1/rm.html",
    "title": "BST623 functions",
    "section": "",
    "text": "rm()\n\nrm(things)\n\n\n\nWhat it does\nThe rm() function removes an object from Râ€™s working memory.\n\n\nDemo code\n\nlife_the_universe_and_everything <- 42\nrm(life_the_universe_and_everything)\n\n\n\nUsefull stuff\nNA\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class1/dplyr::filter.html",
    "href": "notes/Class1/dplyr::filter.html",
    "title": "BST623 functions",
    "section": "",
    "text": "dplyr::filter()\n\n\n{.center}\n\n\n\nWhat it does\n.center[filter(tableName, logical test)] + Use filter() to pick rows/records. Inside the () you put a logic check. filter() keeps rows/records where the logic check is true.\n\n\nDemo code\n\nfilter(mtcars, am == 0)  # cars with automatic transmission\nfilter(mtcars, is.na(mpg))  # cars missing miles per gallon information\nfilter(mtcars, !is.na(mpg))  # cars not missing miles per gallon information\n\n\n\nUsefull stuff\nNA\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class1/library.html",
    "href": "notes/Class1/library.html",
    "title": "BST623 functions",
    "section": "",
    "text": "library()\n\nlibrary(package)\n\n\n\nWhat it does\n\nThe library library() function loads a package into working memory (from long term storage on your hard disk drive or solid state drive).\n\n\n\nDemo code\n\nlibrary(survial)\n\n\n\nUsefull stuff\n\nThere are a few â€œmetaâ€ packages, like tidymodels and tidyverse, which load many packages from a single library() function call. ??? stats::filter and dplyr::filter\n\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class1/remotes::install_cran.html",
    "href": "notes/Class1/remotes::install_cran.html",
    "title": "BST623 functions",
    "section": "",
    "text": "remotes::install_cran()\n\nremotes::install_cran(â€œthingyâ€)\n\n\n\nWhat it does\n\nA better way to add packages is to use the install_cran() function from the remotes package.\n\n\n\nDemo code\n\nremotes::install_cran(\"DOPE\")\n\nPaste that line into the Console windowpane (bottom left corner) and tap the return or enter key on your keyboard.\n\n\nUsefull stuff\n\nIt will check to see the package has been updated before it bothers to do the download.\n\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class1/suppressPackageStartupMessages.html",
    "href": "notes/Class1/suppressPackageStartupMessages.html",
    "title": "BST623 functions",
    "section": "",
    "text": "suppressPackageStartupMessages()\n\nsuppressPackageStartupMessages(library(package))\n\n\n\nWhat it does\n\nLoad a package without printing its greeting message.\n\n\n\nDemo code\n\nsuppressPackageStartupMessages(library(tidyverse))\n\n\n\nUsefull stuff\n\nThis is very useful with the tidyverse and tidymodels. Use this if and only if you are also using the conflicted package (to avoid function name conflicts).\n\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  }
]