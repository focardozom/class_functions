[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "BST623 Software Tools for Manuscript Development and Reproducible Research is a course at the University of Miami, offered by the Biostatistics program. This class is taught by professor, Dr.¬†Raymond Balise. The course focus on the use of software tools for creating professional-quality manuscripts and conducting reproducible research. Whether you‚Äôre an experienced researcher or just starting out, BST 623 will provide valuable skills and knowledge to use R for your research."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "Welcome to the BST623 R Programming resource page! This site provides a collection of functions commonly used in the BST623 class, making it easier for you to access and utilize R programming tools in your coursework. Whether you‚Äôre a seasoned programmer or new to R, this page is designed to provide a comprehensive and user-friendly experience. Happy coding!"
  },
  {
    "objectID": "notes/Class4/table1::table1.html",
    "href": "notes/Class4/table1::table1.html",
    "title": "BST623 functions",
    "section": "",
    "text": "table1::table1()\n\ntable1(formula, dataset)\n\n\n\nWhat it does\n\ntable1() is an excellent tool for taking a quick look at a dataset.\n\n\n\nDemo code\n\ntable1::table1(~ alcgp + tobgp | agegp, data=esoph)\n\n\n\nUsefull stuff\n\nIt will make a simple table with a basic fomula ~ *variable* + *variable(s)*\nIt will make a table summarizing subgroups with a formula that includes a | *variable*\nThe gt package with gtsummary is more powerful (including p-values) but it requires more code.\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/dplyr::if_else.html",
    "href": "notes/Class4/dplyr::if_else.html",
    "title": "BST623 functions",
    "section": "",
    "text": "dplyr::if_else()\n\nif_else(check, true, false)\n\n\n\nWhat it does\n\nif_else() checks the truth of a logic check on a variable/vector and returns the true argument if it is true or the false argument otherwise.\n\n\n\nDemo code\n\nif_else(mtcars$am == 0, \"Automatic\", \"Manual\")\n\n\n\nUsefull stuff\n\nThe logic check can involve any number of variables.\nif_else() is often used with dplyr::mutate()\nif_else() is dangerous because unexpected values can be binned in the false level/group.\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/pillar::glimpse.html",
    "href": "notes/Class4/pillar::glimpse.html",
    "title": "BST623 functions",
    "section": "",
    "text": "pillar::glimpse()\n\n\nglimpse(dataset){.center}\n\n\n\nWhat it does\n\nglimpse() is a convenient alternative to str() for when you want quick look at dataset.\nglimpse() shows the ‚Äútype of‚Äù each column of data. .pull-left[\nint = ‚Äúinteger‚Äù for numbers without decimals\ndbl = ‚Äúdouble‚Äù for numbers with decimals\nlgl = ‚Äúlogical‚Äù for true/false\ndate = ‚Äúdate‚Äù.pull-right[\nchr = ‚Äúcharacter‚Äù for character string\nfct = ‚Äúfactor‚Äù for categories that are not ordered\nord = ‚Äúordered‚Äù for ordered categories ]\n\n\n\nDemo code\n\npillar::glimpse(iris)\n\nRows: 150\nColumns: 5\n$ Sepal.Length <dbl> 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9, 5.4, 4.‚Ä¶\n$ Sepal.Width  <dbl> 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1, 3.7, 3.‚Ä¶\n$ Petal.Length <dbl> 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5, 1.5, 1.‚Ä¶\n$ Petal.Width  <dbl> 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1, 0.2, 0.‚Ä¶\n$ Species      <fct> setosa, setosa, setosa, setosa, setosa, setosa, setosa, s‚Ä¶\n\n\n]\n\n\nUsefull stuff\n\nglimpse() is in the pillar package but it automatically is loaded with either dplyr or tibble. ]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/format.html",
    "href": "notes/Class4/format.html",
    "title": "BST623 functions",
    "section": "",
    "text": "format()\n\nformat(number(s), scientific=FALSE)\n\n\n\nWhat it does\n\nUse format() to display numbers and text many formats and alignment options.\n\n\n\nDemo code\n\nhuge <- 1000000000000000\nformat(huge, big.mark=\",\", scientific=FALSE)\n\n[1] \"1,000,000,000,000,000\"\n\n\n\n\nUsefull stuff\n\nformat() is useful for showing huge and tiny numbers without scientific notation.\nformat() can be use display aligned text.\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/noquote.html",
    "href": "notes/Class4/noquote.html",
    "title": "BST623 functions",
    "section": "",
    "text": "noquote()\n\nnoquote(text)\n\n\n\nWhat it does\n\nThe print() function prints without quotes. noquote() function prints without quotes.\n\n\n\nDemo code\n\nnoquote('The cyberman said \"error.\"')\n\n[1] The cyberman said \"error.\"\n\n\n\n\nUsefull stuff\n\nThis is similar to paste(text, quote = FALSE) but if you save a noquote object it will remember the object should not be quoted.\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/tibble::tribble.html",
    "href": "notes/Class4/tibble::tribble.html",
    "title": "BST623 functions",
    "section": "",
    "text": "tibble::tribble()\n\ntribble(thing(s))\n{.center}\n\n\n\nWhat it does\n\nThe tribble() function let you enter rows of data.\n\n\n\nDemo code\n\nfam <-\n  tribble(\n    ~Name,     ~Species,\n    \"Raymond\", \"homo sapiens\",\n    \"Snowy\",   \"canis lupus familiaris\",\n    \"Crab\",    \"anomuran decapod crustaceans\"\n  )\n\n\n\nUsefull stuff\n\nRemember the names have a + ~ prefix.\nEvery element (except the last) is followed by a comma.\nYou can use spacing to make the code easier to read. .related-functions[] See ‚Äúfun facts on the tibble slide. ]\n\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/select.html",
    "href": "notes/Class4/select.html",
    "title": "BST623 functions",
    "section": "",
    "text": "select()‚Äôs Helper Functions\n\n\n{.center}\n\n\n\nWhat it does\n\nstarts_with(\"X\"): every name that starts with ‚ÄúX‚Äù\nends_with(\"X\"): every name that ends with ‚ÄúX‚Äù\ncontains(\"X\"): every name that contains ‚ÄúX‚Äù\nmatches(\"X\"): every name that matches ‚ÄúX‚Äù, where ‚ÄúX‚Äù can be a regular expression\nnum_range(\"x\", 1:5): the variables named x01, x02, x03, x04 and x05\none_of(x): every name that appears in x, which should be a character vector\n\n\n\nDemo code\n\nlaryngectomy |> \n   select(`ends_with(\"_fu\")`) |> \n   head(n = 2)  # only keep first two records (to fit on the slide)\n\n\n\n# A tibble: 2 √ó 3\n  length_fu death_fu recur_fu\n      <dbl>    <dbl>    <dbl>\n1       103       NA       NA\n2       240       NA       NA\n\n\n\n\nUsefull stuff\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/dput.html",
    "href": "notes/Class4/dput.html",
    "title": "BST623 functions",
    "section": "",
    "text": "dput()\n\ndput(thingy)\n\n\n\nWhat it does\n\nPrint a text version of any object in the console (by default).\n\n\n\nDemo code\n\ndput(names(iris))\n\nc(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\", \n\"Species\")\n\n\n\n\nUsefull stuff\n\nIt is very convenient if you want to get a set of variable names for later processing.\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/table.html",
    "href": "notes/Class4/table.html",
    "title": "BST623 functions",
    "section": "",
    "text": "table()\n\ntable(vector(s))\n\n\n\nWhat it does\n\nMake a summary table of a vector or a pair of vectors.\n\n\n\nDemo code\n\ntable(iris$Species)\n\n\n    setosa versicolor  virginica \n        50         50         50 \n\ntable(mtcars$cyl, mtcars$vs)\n\n   \n     0  1\n  4  1 10\n  6  3  4\n  8 14  0\n\n\n\n\nUsefull stuff\n\ntable() does not have a dataset option and it does not label well.\nIt is well suited for quick checks while debugging. ]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/rep.html",
    "href": "notes/Class4/rep.html",
    "title": "BST623 functions",
    "section": "",
    "text": "rep()\n\nrep(value, #)\n\n\n\nWhat it does\n\nThe rep() function is used to repeat something.\n\n\n\nDemo code\n\nrep(\"Cup of Coffee\", 3)\nfam <-\n  tibble(\n    name_first = c(\"Raymond\", \"Lori\", \"Mary\", \"Andrew\", \"Ella\", \"Snowy\", \"Mia\", \"Crab\"),\n    name_last = c(rep(\"Balise\", 4), \"Johnson\", rep(\"Balise\", 3)),\n    species = c(rep(\"human\", 5), c(\"Canis lupus familiaris\", 2), \"anomuran decapod crustaceans\")\n  )\n\n\n\nUsefull stuff\n\nWhen creating a new dataset, the base R data.frame function will try to repeat (recycle) values if a variable/column is ‚Äúshort‚Äù (i.e., a value is missing). This can be problematic. The tibble function does not automatically recycle values. Use rep() rather that repeatedly typing the same value.\nrep() function can do complex repeating patters. rep(c(‚Äúfun‚Äù, ‚Äúado‚Äù, ‚Äútree‚Äù), c(1, 2, 3))\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/tidyr::drop_na.html",
    "href": "notes/Class4/tidyr::drop_na.html",
    "title": "BST623 functions",
    "section": "",
    "text": "tidyr::drop_na()\n\ndrop_na(dataset)\n\n\n\nWhat it does\n\nUse tidyr::drop_na() to create a dataset with ‚Äúcomplete cases‚Äù (i.e., only keep people with complete data).\n\n\n\nDemo code\n\nlaryngectomy %>%\n  drop_na()\n\n\n\nUsefull stuff\n\nThere is no easy dplyr function to find records without any missing data.\nIf you love to type you can write a dplyr::filter() function call to check for no missing data in all variables.\n\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/dplyr::mutate.html",
    "href": "notes/Class4/dplyr::mutate.html",
    "title": "BST623 functions",
    "section": "",
    "text": "dplyr::mutate()\n\nmutate(data, variable = stuff)\n\n\n\nWhat it does\n\nmutate() is used to create and manipulate variables in the tidyverse ecosystem.\n\n\n\nDemo code\n\nmtcars |> \n  mutate(Transmition = if_else(am == 0, \"Automatic\", \"Manual\"),\n         Transmition = factor(Transmition))\n\n\n\nUsefull stuff\n\nYou can have any number of comma delimited mutations in one function call.\nThe if_else() and case_when() functions are particularly useful with mutate().\nmutate() can apply the same mutation to multiple values if it is mixed with the across() function: mutate(across(c(vs, am), factor)).\n\n\nmtcars |> \n  mutate(\n    across(c(vs, am), factor)\n  )\n\n]\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/slice_sample.html",
    "href": "notes/Class4/slice_sample.html",
    "title": "BST623 functions",
    "section": "",
    "text": "slice_sample() grabs a few records.\n\n\n{.center}\n\n\n\nWhat it does\nIf you have a lot of data, you can easily use slice_sample() with the n = or prop = arguments to take a sample for doing preliminary work. Be sure to use the base R set.seed() function before slice_sample() to specify which set of random records to select.\n\n\nDemo code\n\nset.seed(123)\nlaryngectomy |> \n  select(age, gender, recur_site, trt_mod, int_stg, recur_stg)  |> \n  slice_sample(prop = .05)  # a random 5% of the data\n\n# A tibble: 6 √ó 6\n    age gender recur_site trt_mod int_stg recur_stg\n  <dbl>  <dbl>      <dbl>   <dbl>   <dbl>     <dbl>\n1    70      1          3       1       2         3\n2    66      1          2       1       1         2\n3    81      1          2       1       2         4\n4    74      1          2       2       2         2\n5    83      1          3       1       1         3\n6    84      1          2       1       1         3\n\n\n\n\nUsefull stuff\nNA\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/str.html",
    "href": "notes/Class4/str.html",
    "title": "BST623 functions",
    "section": "",
    "text": "str()\n\nstr(thingy)\n\n\n\nWhat it does\n\nUseful you to see information on the structure of any. It is somewhat useful for datasets.\n\n\n\nDemo code\n\nstr(iris)\n\n'data.frame':   150 obs. of  5 variables:\n $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...\n $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...\n $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...\n $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...\n $ Species     : Factor w/ 3 levels \"setosa\",\"versicolor\",..: 1 1 1 1 1 1 1 1 1 1 ...\n\n\n\n\nUsefull stuff\n\nThe output an be voluminous.\n\n\nstr(\n  lm(height~weight, data= women)\n)\n\n\nglimpse() is often more useful. ]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/dplyr::filter.html",
    "href": "notes/Class4/dplyr::filter.html",
    "title": "BST623 functions",
    "section": "",
    "text": "dplyr::filter()\n\nfilter(tableName, logical test)\n\n\n\nWhat it does\n\nUse filter() to pick rows/records.\nInside the () you put a logic check.\nfilter() keeps rows/records where the logic check is true.\n\n\n\nDemo code\n\nlaryngectomy %>%\n  filter(death == 1)  # the people who died\nlaryngectomy %>%\n  filter(is.na(pathology))  # people missing pathology\nlaryngectomy %>%\n  filter(!is.na(pathology))  # people not missing pathology\nlaryngectomy %>%\n  filter(pathology %in% c(1, 2)) # people with values of 1 or 2\n\n\n\nUsefull stuff\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/names.html",
    "href": "notes/Class4/names.html",
    "title": "BST623 functions",
    "section": "",
    "text": "#names()\n\nnames(thingy)\n\n\nWhat it does\n\nIf you want a print the variable names in a dataset.\n\n\n\nDemo code\n\nnames(iris)\n\n[1] \"Sepal.Length\" \"Sepal.Width\"  \"Petal.Length\" \"Petal.Width\"  \"Species\"     \n\n\n\n\nUsefull stuff\n\n\nCommon Problems\n\nI frequently use it with dput()\n\n\ndput(names(iris))\n\nc(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\", \n\"Species\")\n\n\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/?.html",
    "href": "notes/Class4/?.html",
    "title": "BST623 functions",
    "section": "",
    "text": "?\n\n?thingy\n\n\n\nWhat it does\n\nOpen the help file for an object that you don‚Äôt understand. It is useful to find variable definitions for some datasets and some function argument details.\n\n\n\nDemo code\n\n?women\n\n\n\nUsefull stuff\n\nNote: There is no help file for for men. ?men .\n\n\n?men\n\nNo documentation for 'men' in specified packages and libraries:\nyou could try '??men'\n\n\n\n\nCommon Problems\n\n?? does a broader search in the local documentation.\n\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/c.html",
    "href": "notes/Class4/c.html",
    "title": "BST623 functions",
    "section": "",
    "text": "c() is smart! \\(_1\\)\n\n\n{.center}\n\n\n\nWhat it does\n\nRemember from ‚Äútopic 1‚Äù that R pays attention to the class/type objects.\nc() will notice if the parts that you are combining are numbers or text and it will make the object the correct class/type.\n\n\n\nDemo code\n.pull-left-36[\n\nages <- c(17, 18, 40, 39)\nclass(ages)\n\n[1] \"numeric\"\n\nages\n\n[1] 17 18 40 39\n\n\n]  ‚Äì .pull-right-60[\n\nages <- c(\"seventeen\", \"eighteen\", \"forty\", \"thirty nine\")\nclass(ages)\n\n[1] \"character\"\n\nages\n\n[1] \"seventeen\"   \"eighteen\"    \"forty\"       \"thirty nine\"\n\n\n]\n\n\nUsefull stuff\nNA\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/dplyr::select.html",
    "href": "notes/Class4/dplyr::select.html",
    "title": "BST623 functions",
    "section": "",
    "text": "dplyr::select()\n\nselect(dataset, variables)\n\n\n\nWhat it does\n\nUse select() to choose variables to keep in a new dataset.\n\n\n\nDemo code\n\nlaryngectomy %>%\n  `select(age, gender, death_fu)`\ncomplications <- laryngectomy %>%\n   select(complications`:`comp_2plus)\n\n\n\nUsefull stuff\n\nselect() does not do autocomplete.\nYou can refer to variables by position number. The first variable is 1. ü§¢.\nYou can .red[remove/exclude] unwanted variables with a -:\n\n\nwithoutComplicationVars <- laryngectomy |> \n   select(`-`(complications:comp_2plus))\n\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/New Pipe.html",
    "href": "notes/Class4/New Pipe.html",
    "title": "BST623 functions",
    "section": "",
    "text": "New Pipe |>\n\nthing |> thing\n\n\n\nWhat it does\n\nThe base R pipe, |>, is designed to pass an object into the first argument of another function.\n\n\n\nDemo code\n\nmtcars |> subset(cyl == 4) |> head()\n\n\n\nUsefull stuff\n\nThis pipe is faster than the magrittr pipe (i.e., %>%).\nIt can not redirect to any argument other than the first.\nIt is of limited use because many critical functions (e.g., lm() and plot()) do not take a dataset as the first argument.\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/dplyr::rename.html",
    "href": "notes/Class4/dplyr::rename.html",
    "title": "BST623 functions",
    "section": "",
    "text": "dplyr::rename()\n\n\nYou can easily tweak a variable‚Äôs name with:rename(tableName, newName = oldName) {.center}\n\n\n\nWhat it does\n\n\nDemo code\n\nlaryngectomy |> \n  rename(sex = gender)  # from gender to sex\n\n# A tibble: 123 √ó 32\n     age   sex recur_s‚Ä¶¬π trt_mod int_stg recur‚Ä¶¬≤ preop‚Ä¶¬≥ nk_di‚Ä¶‚Å¥ Later‚Ä¶‚Åµ mic_v‚Ä¶‚Å∂\n   <dbl> <dbl>     <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n 1    54     1         2       1       2       3       1       2      NA       2\n 2    73     1         1       2       3       3       1       1       1       2\n 3    74     1         1       1       2       2       1       2      NA       2\n 4    58     1         1       2       2       3       3       1       1       1\n 5    70     1         2       1       1       4       2       1       1       2\n 6    60     1         2       1       1       4       1       1       1       1\n 7    61     1         2       2       4       3       3       1       1       2\n 8    73     1         3       1       1       3       1       1       1       2\n 9    83     1         2       1       2       2       2       1       1       2\n10    63     1         3       1       2       4       2       1       2       2\n# ‚Ä¶ with 113 more rows, 22 more variables: pec_flap <dbl>, pathology <dbl>,\n#   path_stg <dbl>, complications <dbl>, fistula <dbl>, wound_inf <dbl>,\n#   dehiscence <dbl>, wound_comp <dbl>, chyle_leak <dbl>, hematoma <dbl>,\n#   revision_proc <dbl>, flap_fail <dbl>, periop_death <dbl>, med_comp <dbl>,\n#   comp_2plus <dbl>, hosp_stay <dbl>, death <dbl>, recur <dbl>, sor <dbl>,\n#   length_fu <dbl>, death_fu <dbl>, recur_fu <dbl>, and abbreviated variable\n#   names ¬π‚Äãrecur_site, ¬≤‚Äãrecur_stg, ¬≥‚Äãpreop_Img_mod, ‚Å¥‚Äãnk_dissection, ‚Ä¶\n\n\n]\n\n\nUsefull stuff\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class4/tibble::tibble.html",
    "href": "notes/Class4/tibble::tibble.html",
    "title": "BST623 functions",
    "section": "",
    "text": "tibble::tibble()\n\ntibble(thing(s))\n{.center}\n\n\n\nWhat it does\n\nThe tibble() function will convert base R vectors or a data.frame into a tidyverse tibble\n\n\n\nDemo code\n\nmtcars <- as_tibble(mtcars)\nfam <-\n  tibble(\n    \\`First Name` = c(\"Raymond\", \"Lori\", \"Mary\", \"Andrew\", \"Ella\", \"Snowy\", \"Mia\", \"Crab\"),\n    \\`Last Name` = c(rep(\"Balise\", 4), \"Johnson\", rep(\"Balise\", 3)),\n    species = c(rep(\"h. sapiens\", 5), c(\"canis lupus familiaris\", 2), \"anomuran decapod crustaceans\")\n  )\n\n\n\nUsefull stuff\n\ntibbles have a useful print method.\ntibbles do not use row names. Convert row names to a variable with rownames_to_column()\nThey do not accept partial matching (i.e., fam$F does not work).\ntibbles do not automatically change data.\n\nCharacter variables do not become factors!\nColumn names are not converted to base names (e.g.¬†spaces are allowed). ]\n\n\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class2/%>%.html",
    "href": "notes/Class2/%>%.html",
    "title": "BST623 functions",
    "section": "",
    "text": "%>%\n\n\\(thing_1\\) %>%\n\\(thing_2\\) {.center}\n\n\n\nWhat it does\n\nThe symbol %>% is called a pipe. When describing a workflow, it is spoken as ‚Äúthen‚Äù.\nIt sends the output from \\(thing_1\\) to the first argument of \\(thing_2\\).\n\n\n\nDemo code\n\nnrow(medicaldata::covid_testing) %>%\n  scales::comma() %>%\n  print()\n\n\n\nUsefull stuff\n\nMany functions can be connected in a pipeline.\nStart code after a pipe on a new line.\nIndent all lines of code two spaces after the first pipe. .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class2/R.Version.html",
    "href": "notes/Class2/R.Version.html",
    "title": "BST623 functions",
    "section": "",
    "text": "R.Version()\n\nR.Version()\n\n\n\nWhat it does\n\nR.Version() returns a list of details about the version of that is currently running.\n\n\n\nDemo code\n\nR.Version()\n\n\n\nUsefull stuff\n.center[R.version.string] + R.version.string is an easier to work with description of your version of R:\n\nR.version.string\n\n\nThis is useful for extracting the version of R for publications: stringr::word(R.version.string, 1, 3) .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class2/suppressMessages.html",
    "href": "notes/Class2/suppressMessages.html",
    "title": "BST623 functions",
    "section": "",
    "text": "suppressMessages()\n\nsuppressMessages(function)\n\n\n\nWhat it does\n\nThis will muffle messages produced by a chatty function.\n\n\n\nDemo code\n\nsuppressMessages(library(h2o))\n\n\n\nUsefull stuff\n\nIt may be clearer to write: library(*package*, quietly = TRUE).\nThis helps with packages that are chatty even when using the quietly = TRUE argument to library().\nThis prevents many messages from showing up in R Markdown output without suppressing other critical messages. .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class2/mean.html",
    "href": "notes/Class2/mean.html",
    "title": "BST623 functions",
    "section": "",
    "text": "mean()\n\nmean(vector, na.rm = value)\n\n\n\nWhat it does\n\nIt calculates an average.\nBy default it returns NA is any value is missing.\nYou normally use this on a typical numeric variable but it can be use for other types of data if it can convert them to numbers (like dates/times).\n\nYou can also calculate the average on a logical (TRUE/FALSE) variable to get the percent true. Remember: 1=TRUE/YES, 0=FALSE/NO in everything you do.\n\n\n\n\nDemo code\n\nmean(mtcars$mpg)\n\n[1] 20.09062\n\nmean(TRUE)\n\n[1] 1\n\n\n]\n\n\nUsefull stuff\n.related-functions[]\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class2/knitr::opts_chunk$set.html",
    "href": "notes/Class2/knitr::opts_chunk$set.html",
    "title": "BST623 functions",
    "section": "",
    "text": "knitr::opts_chunk$set()\n\nknitr::opts_chunk$set(option = value)\n\n\n\nWhat it does\n\nThis command allows you to set the default behavior for code chunks when knitting\nFor example, this specifies that you want to always show code but never run it\n\n\n\nDemo code\n\nknitr::opts_chunk$set(echo = TRUE, eval = FALSE)\n\n\n\nUsefull stuff\n\nThis command belongs in the ‚Äúsetup‚Äù chunk at the top of an R Markdown script.\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class2/conflicted::conflicted_prefer.html",
    "href": "notes/Class2/conflicted::conflicted_prefer.html",
    "title": "BST623 functions",
    "section": "",
    "text": "conflicted::conflicted_prefer()\n\n\nconflicted_prefer(‚Äúfunction‚Äù, ‚Äúwinning package‚Äù, quiet = TRUE){.center}\n\n\n\nWhat it does\n\nThe conflicted packages complains when the same function name is used in multiple packages.\nUse conflicted_prefer() to specify which version should be used by default.\n\n\n\nDemo code\n\nconflict_prefer(\"filter\", \"dplyr\", quiet = TRUE)\n\n\n\nUsefull stuff\n\nYou can overwrite this default with package::function().\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class2/scales::comma.html",
    "href": "notes/Class2/scales::comma.html",
    "title": "BST623 functions",
    "section": "",
    "text": "scales::comma()\n\nscales::comma(number)\n\n\n\nWhat it does\n\nIt adds commas to number.\n\n\n\nDemo code\n\n\nUsefull stuff\n\nscales::comma(9001)\n\n\nThis is extremely useful when preparing R Markdown reports. .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class2/<-.html",
    "href": "notes/Class2/<-.html",
    "title": "BST623 functions",
    "section": "",
    "text": "<-\n\nthingy <- something\n\n\n\nWhat it does\n\nYou use <- to assign an object (e.g., thingy) a value (e.g., something).\nThe <- operator is pronounced ‚Äúgets‚Äù.\nIn other languages this would be an =.\n\n\n\nDemo code\n\neverything <- 42\n\n\n\nUsefull stuff\n\nYou can also use -> (e.g., something -> thingy) but it violates all style guides.\n\n\n\nCommon Problems\n\nUse an =, not <- , to assign values to an argument in a function call.\n\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class2/rUM::make_project\"\".html",
    "href": "notes/Class2/rUM::make_project\"\".html",
    "title": "BST623 functions",
    "section": "",
    "text": "rUM::make_project(\"\")\n\nmake_project(‚Äúlocation‚Äù)\n\n\n\nWhat it does\n\nThis copies the ‚Äúshell‚Äù for an academic paper into a folder/directory.\nFor example, this copies the rUM files into the current folder:\n\n\n\nDemo code\n\nrUM::make_project(\"./\")\n\n\n\nUsefull stuff\n\nIt is probably easier to use the New Project Wizard from the File menu and choose Research Project Template. .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class2/stringr::word.html",
    "href": "notes/Class2/stringr::word.html",
    "title": "BST623 functions",
    "section": "",
    "text": "stringr::word()\n\nword(sentence), start, stop*{.center}\n\n\n\nWhat it does\n\nUse this to extract words from a sentence.\n\n\n\nDemo code\n\nwisdom <- \"Caesar salad was created by an Italian in Mexico.\"\nstringr::word(wisdom, 7, 9)\n\n[1] \"Italian in Mexico.\"\n\n\n\n\nUsefull stuff\n\nThis is useful for extracting the version of R for publications: stringr::word(R.version.string, 1, 3) .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class2/nrow.html",
    "href": "notes/Class2/nrow.html",
    "title": "BST623 functions",
    "section": "",
    "text": "nrow()\n\nnrow(dataset)\n\n\n\nWhat it does\n\nnrow() reports the number of rows/records in a dataset (or matrix).\n\n\n\nDemo code\n\nnrow(mtcars)\n\n[1] 32\n\n\n\n\nUsefull stuff\n\nYou will likely use this with scales::comma() to include the number of observations in a dataset as part of a report.\n\n\nscales::comma(\n  nrow(medicaldata::covid_testing)\n)\n\n[1] \"15,524\"\n\n\n.related-functions[]\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class2/remotes::install_github.html",
    "href": "notes/Class2/remotes::install_github.html",
    "title": "BST623 functions",
    "section": "",
    "text": "remotes::install_github()\n\nremotes::install_github(author/package)\n\n\n\nWhat it does\n\nDownloads and install a package from from www.github.com.\n\n\n\nDemo code\n\nremotes::install_github(\"RaymondBalise/rUM\")\n\n\n\nUsefull stuff\n\nUse this release to get the latest bug fixes.\nIt checks to see if there is any new content before it downloads.\nYou will need tools to build packages.\n\nThese tools ship with Mac.\nOn Windows you will need to install Rtools .related-functions[]\n\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class2/paste0.html",
    "href": "notes/Class2/paste0.html",
    "title": "BST623 functions",
    "section": "",
    "text": "paste0()\n\npaste0(things)\n\n\n\nWhat it does\n\nIt pastes together character strings without adding spaces.\nThe paste0() function prints a slash before quotes.\n\n\n\nDemo code\n\npaste0(\"The cyberman\", \" cried.\")\n\n[1] \"The cyberman cried.\"\n\npaste0('The cyberman said \"error.\"')\n\n[1] \"The cyberman said \\\"error.\\\"\"\n\nwords <- \"Hi Mom\"\npaste0(\"Ray said \", '\"', words, '\".')\n\n[1] \"Ray said \\\"Hi Mom\\\".\"\n\n\n] .related-functions[]\n.pull-right[ + The .blue[paste()] function puts a space between words. + The .blue[glue::glue()] function is an excellent alternative.\n\nwords <- \"Hi Mom\"\nglue::glue('Ray said \"{words}\".')\n\nRay said \"Hi Mom\".\n\n\n] ] .common-problems[]\n\n\nUsefull stuff\nNA\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class2/options.html",
    "href": "notes/Class2/options.html",
    "title": "BST623 functions",
    "section": "",
    "text": "options()\n\n\noptions(option = value){.center}\n\n\n\nWhat it does\n\nThe options() function sets the global behavior used by R, including how numbers are printed/formatted.\n\nSome packages allow you to set default behavior.\n\nFor example, you can turn off messages about how summarise() function behaves in dplyr with this option:\n\n\n\n\nDemo code\n\noptions(dplyr.summarise.inform = FALSE)\n\n\n\nUsefull stuff\n.related-functions[]\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class2/cat.html",
    "href": "notes/Class2/cat.html",
    "title": "BST623 functions",
    "section": "",
    "text": "cat()\n\ncat(things)\n\n\n\nWhat it does\n\ncat() is simpler version of the paste() function.\n\nIt does not print the vector position, like print().\nIt does not prints a slash before quotes.\n\n\n\n\nDemo code\n\ncat(\"The cyberman\", \"cried.\")\n\nThe cyberman cried.\n\ncat('The cyberman said \"error.\"')\n\nThe cyberman said \"error.\"\n\nwords <- \"Hi Mom\"\ncat(\"Ray said \", '\"', words, '\".')\n\nRay said  \" Hi Mom \".\n\n\n]\n\n\nUsefull stuff\n\nThe glue::glue() is an excellent alternative.\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/table1::table1.html",
    "href": "notes/Class3/table1::table1.html",
    "title": "BST623 functions",
    "section": "",
    "text": "table1::table1()\n\ntable1(formula, dataset)\n\n\n\nWhat it does\n\ntable1() is an excellent tool for taking a quick look at a dataset.\n\n\n\nDemo code\n\ntable1::table1(~ alcgp + tobgp | agegp, data=esoph)\n\n\n\nUsefull stuff\n\nIt will make a simple table with a basic fomula ~ *variable* + *variable(s)*\nIt will make a table summarizing subgroups with a formula that includes a | *variable*\nThe gt package with gtsummary is more powerful (including p-values) but it requires more code. .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/dplyr::if_else.html",
    "href": "notes/Class3/dplyr::if_else.html",
    "title": "BST623 functions",
    "section": "",
    "text": "dplyr::if_else()\n\nif_else(check, true, false)\n\n\n\nWhat it does\n\nif_else() checks the truth of a logic check on a variable/vector and returns the true argument if it is true or the false argument otherwise.\n\n\n\nDemo code\n\nif_else(mtcars$am == 0, \"Automatic\", \"Manual\")\n\n\n\nUsefull stuff\n\nThe logic check can involve any number of variables.\nif_else() is often used with dplyr::mutate()\nif_else() is dangerous because unexpected values can be binned in the false level/group. .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/pillar::glimpse.html",
    "href": "notes/Class3/pillar::glimpse.html",
    "title": "BST623 functions",
    "section": "",
    "text": "pillar::glimpse()\n\n\nglimpse(dataset){.center}\n\n\n\nWhat it does\n\nglimpse() is a convenient alternative to str() for when you want quick look at dataset.\nglimpse() shows the ‚Äútype of‚Äù each column of data. .pull-left[\nint = ‚Äúinteger‚Äù for numbers without decimals\ndbl = ‚Äúdouble‚Äù for numbers with decimals\nlgl = ‚Äúlogical‚Äù for true/false\ndate = ‚Äúdate‚Äù.pull-right[\nchr = ‚Äúcharacter‚Äù for character string\nfct = ‚Äúfactor‚Äù for categories that are not ordered\nord = ‚Äúordered‚Äù for ordered categories ]\n\n\n\nDemo code\n\npillar::glimpse(iris)\n\nRows: 150\nColumns: 5\n$ Sepal.Length <dbl> 5.1, 4.9, 4.7, 4.6, 5.0, 5.4, 4.6, 5.0, 4.4, 4.9, 5.4, 4.‚Ä¶\n$ Sepal.Width  <dbl> 3.5, 3.0, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1, 3.7, 3.‚Ä¶\n$ Petal.Length <dbl> 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5, 1.5, 1.‚Ä¶\n$ Petal.Width  <dbl> 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1, 0.2, 0.‚Ä¶\n$ Species      <fct> setosa, setosa, setosa, setosa, setosa, setosa, setosa, s‚Ä¶\n\n\n]\n\n\nUsefull stuff\n\nglimpse() is in the pillar package but it automatically is loaded with either dplyr or tibble. ] .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/format.html",
    "href": "notes/Class3/format.html",
    "title": "BST623 functions",
    "section": "",
    "text": "format()\n\nformat(number(s), scientific=FALSE)\n\n\n\nWhat it does\n\nUse format() to display numbers and text many formats and alignment options.\n\n\n\nDemo code\n\nhuge <- 1000000000000000\nformat(huge, big.mark=\",\", scientific=FALSE)\n\n[1] \"1,000,000,000,000,000\"\n\n\n\n\nUsefull stuff\n\nformat() is useful for showing huge and tiny numbers without scientific notation.\nformat() can be use display aligned text. .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/noquote.html",
    "href": "notes/Class3/noquote.html",
    "title": "BST623 functions",
    "section": "",
    "text": "noquote()\n\nnoquote(text)\n\n\n\nWhat it does\n\nThe print() function prints without quotes. noquote() function prints without quotes.\n\n\n\nDemo code\n\nnoquote('The cyberman said \"error.\"')\n\n[1] The cyberman said \"error.\"\n\n\n\n\nUsefull stuff\n\nThis is similar to paste(text, quote = FALSE) but if you save a noquote object it will remember the object should not be quoted. .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/tibble::tribble.html",
    "href": "notes/Class3/tibble::tribble.html",
    "title": "BST623 functions",
    "section": "",
    "text": "tibble::tribble()\n.center[tribble(thing(s))] .small[ + The tribble() function let you enter rows of data.\n\nfam <-\n  tribble(\n    ~Name,     ~Species,\n    \"Raymond\", \"homo sapiens\",\n    \"Snowy\",   \"canis lupus familiaris\",\n    \"Crab\",    \"anomuran decapod crustaceans\"\n  )\n\n\nRemember the names have a + ~ prefix.\nEvery element (except the last) is followed by a comma.\nYou can use spacing to make the code easier to read. See ‚Äúfun facts on the tibble slide. ]\n\n\nNA\n\n\n\nWhat it does\nNA\n\n\nDemo code\nNA\n\n\nUsefull stuff\nNA\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/select.html",
    "href": "notes/Class3/select.html",
    "title": "BST623 functions",
    "section": "",
    "text": "select()‚Äôs Helper Functions\n\nstarts_with(\"X\"): every name that starts with ‚ÄúX‚Äù\nends_with(\"X\"): every name that ends with ‚ÄúX‚Äù\ncontains(\"X\"): every name that contains ‚ÄúX‚Äù\nmatches(\"X\"): every name that matches ‚ÄúX‚Äù, where ‚ÄúX‚Äù can be a regular expression\nnum_range(\"x\", 1:5): the variables named x01, x02, x03, x04 and x05\none_of(x): every name that appears in x, which should be a character vector\n\n\nlaryngectomy |> \n   select(`ends_with(\"_fu\")`) |> \n   head(n = 2)  # only keep first two records (to fit on the slide)\n\n\n\n# A tibble: 2 √ó 3\n  length_fu death_fu recur_fu\n      <dbl>    <dbl>    <dbl>\n1       103       NA       NA\n2       240       NA       NA\n\n\n\nNA\n\n\n\nWhat it does\nNA\n\n\nDemo code\nNA\n\n\nUsefull stuff\nNA\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/dput.html",
    "href": "notes/Class3/dput.html",
    "title": "BST623 functions",
    "section": "",
    "text": "dput()\n\ndput(thingy)\n\n\n\nWhat it does\n\nPrint a text version of any object in the console (by default).\n\n\n\nDemo code\n\ndput(names(iris))\n\nc(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\", \n\"Species\")\n\n\n\n\nUsefull stuff\n\nIt is very convenient if you want to get a set of variable names for later processing. .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/table.html",
    "href": "notes/Class3/table.html",
    "title": "BST623 functions",
    "section": "",
    "text": "table()\n\ntable(vector(s))\n\n\n\nWhat it does\n\nMake a summary table of a vector or a pair of vectors.\n\n\n\nDemo code\n\ntable(iris$Species)\n\n\n    setosa versicolor  virginica \n        50         50         50 \n\ntable(mtcars$cyl, mtcars$vs)\n\n   \n     0  1\n  4  1 10\n  6  3  4\n  8 14  0\n\n\n\n\nUsefull stuff\n\ntable() does not have a dataset option and it does not label well.\nIt is well suited for quick checks while debugging. ] .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/rep.html",
    "href": "notes/Class3/rep.html",
    "title": "BST623 functions",
    "section": "",
    "text": "rep()\n\nrep(value, #)\n\n\n\nWhat it does\n\nThe rep() function is used to repeat something.\n\n\n\nDemo code\n\nrep(\"Cup of Coffee\", 3)\nfam <-\n  tibble(\n    name_first = c(\"Raymond\", \"Lori\", \"Mary\", \"Andrew\", \"Ella\", \"Snowy\", \"Mia\", \"Crab\"),\n    name_last = c(rep(\"Balise\", 4), \"Johnson\", rep(\"Balise\", 3)),\n    species = c(rep(\"human\", 5), c(\"Canis lupus familiaris\", 2), \"anomuran decapod crustaceans\")\n  )\n\n\n\nUsefull stuff\n\nWhen creating a new dataset, the base R data.frame function will try to repeat (recycle) values if a variable/column is ‚Äúshort‚Äù (i.e., a value is missing). This can be problematic. The tibble function does not automatically recycle values. Use rep() rather that repeatedly typing the same value.\nrep() function can do complex repeating patters. rep(c(‚Äúfun‚Äù, ‚Äúado‚Äù, ‚Äútree‚Äù), c(1, 2, 3)) .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/tidyr::drop_na.html",
    "href": "notes/Class3/tidyr::drop_na.html",
    "title": "BST623 functions",
    "section": "",
    "text": "tidyr::drop_na()\n.center[drop_na(*dataset*)] + Use tidyr::drop_na() to create a dataset with ‚Äúcomplete cases‚Äù (i.e., only keep people with complete data).\n\nlaryngectomy %>%\n  drop_na()\n\n\nThere is no easy dplyr function to find records without any missing data.\nIf you love to type you can write a dplyr::filter() function call to check for no missing data in all variables.\n\n\nNA\n\n\n\nWhat it does\nNA\n\n\nDemo code\nNA\n\n\nUsefull stuff\nNA\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/dplyr::mutate.html",
    "href": "notes/Class3/dplyr::mutate.html",
    "title": "BST623 functions",
    "section": "",
    "text": "dplyr::mutate()\n\nmutate(data, variable = stuff)\n\n\n\nWhat it does\n\nmutate() is used to create and manipulate variables in the tidyverse ecosystem.\n\n\n\nDemo code\n\nmtcars |> \n  mutate(Transmition = if_else(am == 0, \"Automatic\", \"Manual\"),\n         Transmition = factor(Transmition))\n\n\n\nUsefull stuff\n\nYou can have any number of comma delimited mutations in one function call.\nThe if_else() and case_when() functions are particularly useful with mutate().\nmutate() can apply the same mutation to multiple values if it is mixed with the across() function: mutate(across(c(vs, am), factor)).\n\n\nmtcars |> \n  mutate(\n    across(c(vs, am), factor)\n  )\n\n] .related-functions[]\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/slice_sample.html",
    "href": "notes/Class3/slice_sample.html",
    "title": "BST623 functions",
    "section": "",
    "text": "slice_sample() grabs a few records.\n\n\n{.center}\n\n\n\nWhat it does\nIf you have a lot of data, you can easily use slice_sample() with the n = or prop = arguments to take a sample for doing preliminary work. Be sure to use the base R set.seed() function before slice_sample() to specify which set of random records to select.\n\n\nDemo code\n\nset.seed(123)\nlaryngectomy |> \n  select(age, gender, recur_site, trt_mod, int_stg, recur_stg)  |> \n  slice_sample(prop = .05)  # a random 5% of the data\n\n# A tibble: 6 √ó 6\n    age gender recur_site trt_mod int_stg recur_stg\n  <dbl>  <dbl>      <dbl>   <dbl>   <dbl>     <dbl>\n1    70      1          3       1       2         3\n2    66      1          2       1       1         2\n3    81      1          2       1       2         4\n4    74      1          2       2       2         2\n5    83      1          3       1       1         3\n6    84      1          2       1       1         3\n\n\n\n\nUsefull stuff\nNA\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/str.html",
    "href": "notes/Class3/str.html",
    "title": "BST623 functions",
    "section": "",
    "text": "str()\n\nstr(thingy)\n\n\n\nWhat it does\n\nUseful you to see information on the structure of any. It is somewhat useful for datasets.\n\n\n\nDemo code\n\nstr(iris)\n\n'data.frame':   150 obs. of  5 variables:\n $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...\n $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...\n $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...\n $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...\n $ Species     : Factor w/ 3 levels \"setosa\",\"versicolor\",..: 1 1 1 1 1 1 1 1 1 1 ...\n\n\n\n\nUsefull stuff\n\nThe output an be voluminous.\n\n\nstr(\n  lm(height~weight, data= women)\n)\n\n\nglimpse() is often more useful. ] .related-functions[]\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/dplyr::filter.html",
    "href": "notes/Class3/dplyr::filter.html",
    "title": "BST623 functions",
    "section": "",
    "text": "dplyr::filter()\n.center[filter(tableName, logical test)] + Use filter() to pick rows/records. + Inside the () you put a logic check. + filter() keeps rows/records where the logic check is true.\n\nlaryngectomy %>%\n  filter(death == 1)  # the people who died\nlaryngectomy %>%\n  filter(is.na(pathology))  # people missing pathology\nlaryngectomy %>%\n  filter(!is.na(pathology))  # people not missing pathology\nlaryngectomy %>%\n  filter(pathology %in% c(1, 2)) # people with values of 1 or 2\n\n\nNA\n\n\n\nWhat it does\nNA\n\n\nDemo code\nNA\n\n\nUsefull stuff\nNA\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/names.html",
    "href": "notes/Class3/names.html",
    "title": "BST623 functions",
    "section": "",
    "text": "#names()\n\nnames(thingy)\n\n\nWhat it does\n\nIf you want a print the variable names in a dataset.\n\n\n\nDemo code\n\nnames(iris)\n\n[1] \"Sepal.Length\" \"Sepal.Width\"  \"Petal.Length\" \"Petal.Width\"  \"Species\"     \n\n\n\n\nUsefull stuff\n.related-functions[] + I frequently use it with dput()\n\ndput(names(iris))\n\nc(\"Sepal.Length\", \"Sepal.Width\", \"Petal.Length\", \"Petal.Width\", \n\"Species\")\n\n\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/?.html",
    "href": "notes/Class3/?.html",
    "title": "BST623 functions",
    "section": "",
    "text": "?\n\n?thingy\n\n\n\nWhat it does\n\nOpen the help file for an object that you don‚Äôt understand. It is useful to find variable definitions for some datasets and some function argument details.\n\n\n\nDemo code\n\n?women\n\n\n\nUsefull stuff\n\nNote: There is no help file for for men. ?men .\n\n\n?men\n\nNo documentation for 'men' in specified packages and libraries:\nyou could try '??men'\n\n\n.related-functions[] + ?? does a broader search in the local documentation.\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/c.html",
    "href": "notes/Class3/c.html",
    "title": "BST623 functions",
    "section": "",
    "text": "c() is smart! \\(_1\\)\n\nRemember from ‚Äútopic 1‚Äù that R pays attention to the class/type objects.\nc() will notice if the parts that you are combining are numbers or text and it will make the object the correct class/type. .pull-left-36[\n\n\nages <- c(17, 18, 40, 39)\nclass(ages)\n\n[1] \"numeric\"\n\nages\n\n[1] 17 18 40 39\n\n\n]  ‚Äì .pull-right-60[\n\nages <- c(\"seventeen\", \"eighteen\", \"forty\", \"thirty nine\")\nclass(ages)\n\n[1] \"character\"\n\nages\n\n[1] \"seventeen\"   \"eighteen\"    \"forty\"       \"thirty nine\"\n\n\n]\n\nNA\n\n\n\nWhat it does\nNA\n\n\nDemo code\nNA\n\n\nUsefull stuff\nNA\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/dplyr::select.html",
    "href": "notes/Class3/dplyr::select.html",
    "title": "BST623 functions",
    "section": "",
    "text": "dplyr::select()\n.center[select(*dataset*, *variables*)] + Use select() to choose variables to keep in a new dataset.\n\nlaryngectomy %>%\n  `select(age, gender, death_fu)`\ncomplications <- laryngectomy %>%\n   select(complications`:`comp_2plus)\n\n\nselect() does not do autocomplete.\nYou can refer to variables by position number. The first variable is 1. ü§¢.\nYou can .red[remove/exclude] unwanted variables with a -:\n\n\nwithoutComplicationVars <- laryngectomy |> \n   select(`-`(complications:comp_2plus))\n\n\nNA\n\n\n\nWhat it does\nNA\n\n\nDemo code\nNA\n\n\nUsefull stuff\nNA\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/New Pipe.html",
    "href": "notes/Class3/New Pipe.html",
    "title": "BST623 functions",
    "section": "",
    "text": "New Pipe |>\n\nthing |> thing\n\n\n\nWhat it does\n\nThe base R pipe, |>, is designed to pass an object into the first argument of another function.\n\n\n\nDemo code\n\nmtcars |> subset(cyl == 4) |> head()\n\n\n\nUsefull stuff\n\nThis pipe is faster than the magrittr pipe (i.e., %>%).\nIt can not redirect to any argument other than the first.\nIt is of limited use because many critical functions (e.g., lm() and plot()) do not take a dataset as the first argument.\n\n.related-functions[]\n\n\nCommon Problems\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/dplyr::rename.html",
    "href": "notes/Class3/dplyr::rename.html",
    "title": "BST623 functions",
    "section": "",
    "text": "dplyr::rename()\nYou can easily tweak a variable‚Äôs name with: .center[rename(tableName, newName = oldName)] .small[\n\nlaryngectomy |> \n  rename(sex = gender)  # from gender to sex\n\n# A tibble: 123 √ó 32\n     age   sex recur_s‚Ä¶¬π trt_mod int_stg recur‚Ä¶¬≤ preop‚Ä¶¬≥ nk_di‚Ä¶‚Å¥ Later‚Ä¶‚Åµ mic_v‚Ä¶‚Å∂\n   <dbl> <dbl>     <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n 1    54     1         2       1       2       3       1       2      NA       2\n 2    73     1         1       2       3       3       1       1       1       2\n 3    74     1         1       1       2       2       1       2      NA       2\n 4    58     1         1       2       2       3       3       1       1       1\n 5    70     1         2       1       1       4       2       1       1       2\n 6    60     1         2       1       1       4       1       1       1       1\n 7    61     1         2       2       4       3       3       1       1       2\n 8    73     1         3       1       1       3       1       1       1       2\n 9    83     1         2       1       2       2       2       1       1       2\n10    63     1         3       1       2       4       2       1       2       2\n# ‚Ä¶ with 113 more rows, 22 more variables: pec_flap <dbl>, pathology <dbl>,\n#   path_stg <dbl>, complications <dbl>, fistula <dbl>, wound_inf <dbl>,\n#   dehiscence <dbl>, wound_comp <dbl>, chyle_leak <dbl>, hematoma <dbl>,\n#   revision_proc <dbl>, flap_fail <dbl>, periop_death <dbl>, med_comp <dbl>,\n#   comp_2plus <dbl>, hosp_stay <dbl>, death <dbl>, recur <dbl>, sor <dbl>,\n#   length_fu <dbl>, death_fu <dbl>, recur_fu <dbl>, and abbreviated variable\n#   names ¬π‚Äãrecur_site, ¬≤‚Äãrecur_stg, ¬≥‚Äãpreop_Img_mod, ‚Å¥‚Äãnk_dissection, ‚Ä¶\n\n\n]\n\nNA\n\n\n\nWhat it does\nNA\n\n\nDemo code\nNA\n\n\nUsefull stuff\nNA\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class3/tibble::tibble.html",
    "href": "notes/Class3/tibble::tibble.html",
    "title": "BST623 functions",
    "section": "",
    "text": "tibble::tibble()\n.center[tibble(thing(s))] .small[ + The tibble() function will convert base R vectors or a data.frame into a tidyverse tibble\n\nmtcars <- as_tibble(mtcars)\nfam <-\n  tibble(\n    \\`First Name` = c(\"Raymond\", \"Lori\", \"Mary\", \"Andrew\", \"Ella\", \"Snowy\", \"Mia\", \"Crab\"),\n    \\`Last Name` = c(rep(\"Balise\", 4), \"Johnson\", rep(\"Balise\", 3)),\n    species = c(rep(\"h. sapiens\", 5), c(\"canis lupus familiaris\", 2), \"anomuran decapod crustaceans\")\n  )\n\n\ntibbles have a useful print method.\ntibbles do not use row names. Convert row names to a variable with rownames_to_column()\nThey do not accept partial matching (i.e., fam$F does not work).\ntibbles do not automatically change data.\n\nCharacter variables do not become factors!\nColumn names are not converted to base names (e.g.¬†spaces are allowed). ]\n\n\n\nNA\n\n\n\nWhat it does\nNA\n\n\nDemo code\nNA\n\n\nUsefull stuff\nNA\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class1/%>%.html",
    "href": "notes/Class1/%>%.html",
    "title": "BST623 functions",
    "section": "",
    "text": "%>% from the magrittr Package\n\n\\(thing_1\\) %>%\n\\(thing_2\\) {.center}\n\n\n\nWhat it does\n\nThe symbol %>% is called a pipe. When describing a workflow, it is spoken as ‚Äúthen‚Äù.\nIt normally sends the output from \\(thing_1\\) to the first argument of \\(thing_2\\).\n\n\n\nDemo code\n\nmtcars %>%\n  filter(mpg == 30.4)\n\n\n\nUsefull stuff\n\nMany functions can be connected in a pipeline.\nStart code after a pipe on a new line.\nIndent all lines of code two spaces after the first pipe.\n\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class1/dplyr::pull.html",
    "href": "notes/Class1/dplyr::pull.html",
    "title": "BST623 functions",
    "section": "",
    "text": "dplyr::pull()\n\npull(dataset, variable)\n\n\n\nWhat it does\n\nThe pull() is used to copy of a variable out of a dataset into a new object.\n\n\n\nDemo code\n\npull(mtcars, mpg)\n\n\n\nUsefull stuff\n\nWhen it is used with the filter() function, pull() can be used to extract a single value from a dataset. This is useful when you need to extract a number, like an odds ratio or a p-value, for a report.\npull() is the only dplyr function that does not return a tibble.\n\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class1/class.html",
    "href": "notes/Class1/class.html",
    "title": "BST623 functions",
    "section": "",
    "text": "class()\n\nclass(thingy)\n\n\n\nWhat it does\nIf you are not sure what something is, you can check its class by typing using the class() function in the console windowpane.\n\n\nDemo code\n\nclass(iris)\n\n\n\nUsefull stuff\n.pull-left[.center[]] .pull-right[.center[]]\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class1/rm.html",
    "href": "notes/Class1/rm.html",
    "title": "BST623 functions",
    "section": "",
    "text": "rm()\n\nrm(things)\n\n\n\nWhat it does\nThe rm() function removes an object from R‚Äôs working memory.\n\n\nDemo code\n\nlife_the_universe_and_everything <- 42\nrm(life_the_universe_and_everything)\n\n\n\nUsefull stuff\nNA\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class1/dplyr::filter.html",
    "href": "notes/Class1/dplyr::filter.html",
    "title": "BST623 functions",
    "section": "",
    "text": "dplyr::filter()\n\nfilter(tableName, logical test)\n\n\n\nWhat it does\n\nUse filter() to pick rows/records. Inside the () you put a logic check. filter() keeps rows/records where the logic check is true.\n\n\n\nDemo code\n\nfilter(mtcars, am == 0)  # cars with automatic transmission\nfilter(mtcars, is.na(mpg))  # cars missing miles per gallon information\nfilter(mtcars, !is.na(mpg))  # cars not missing miles per gallon information\n\n\n\nUsefull stuff\nNA\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class1/library.html",
    "href": "notes/Class1/library.html",
    "title": "BST623 functions",
    "section": "",
    "text": "library()\n\nlibrary(package)\n\n\n\nWhat it does\n\nThe library library() function loads a package into working memory (from long term storage on your hard disk drive or solid state drive).\n\n\n\nDemo code\n\nlibrary(survial)\n\n\n\nUsefull stuff\n\nThere are a few ‚Äúmeta‚Äù packages, like tidymodels and tidyverse, which load many packages from a single library() function call. ??? stats::filter and dplyr::filter\n\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class1/remotes::install_cran.html",
    "href": "notes/Class1/remotes::install_cran.html",
    "title": "BST623 functions",
    "section": "",
    "text": "remotes::install_cran()\n\nremotes::install_cran(‚Äúthingy‚Äù)\n\n\n\nWhat it does\n\nA better way to add packages is to use the install_cran() function from the remotes package.\n\n\n\nDemo code\n\nremotes::install_cran(\"DOPE\")\n\nPaste that line into the Console windowpane (bottom left corner) and tap the return or enter key on your keyboard.\n\n\nUsefull stuff\n\nIt will check to see the package has been updated before it bothers to do the download.\n\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  },
  {
    "objectID": "notes/Class1/suppressPackageStartupMessages.html",
    "href": "notes/Class1/suppressPackageStartupMessages.html",
    "title": "BST623 functions",
    "section": "",
    "text": "suppressPackageStartupMessages()\n\nsuppressPackageStartupMessages(library(package))\n\n\n\nWhat it does\n\nLoad a package without printing its greeting message.\n\n\n\nDemo code\n\nsuppressPackageStartupMessages(library(tidyverse))\n\n\n\nUsefull stuff\n\nThis is very useful with the tidyverse and tidymodels. Use this if and only if you are also using the conflicted package (to avoid function name conflicts).\n\n\n\nCommon Problems\nNA\n\n\nRelated Functions\nNA"
  }
]