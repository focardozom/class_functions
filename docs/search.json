[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "Welcome to the BST623 R Programming resource page! This site provides a collection of functions commonly used in the BST623 class, making it easier for you to access and utilize R programming tools in your coursework. Whether you’re a seasoned programmer or new to R, this page is designed to provide a comprehensive and user-friendly experience. Happy coding!"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "BST623 Software Tools for Manuscript Development and Reproducible Research is a course at the University of Miami, offered by the Biostatistics program. This class is taught by professor, Dr. Raymond Balise. The course focus on the use of software tools for creating professional-quality manuscripts and conducting reproducible research. Whether you’re an experienced researcher or just starting out, BST 623 will provide valuable skills and knowledge to use R for your research."
  },
  {
    "objectID": "notes/Class3/suppressMessages.html",
    "href": "notes/Class3/suppressMessages.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: suppressMessages\n\n\nNotes:\n#.blue[suppressMessages()] .center[.blue[suppressMessages](*function*)] + This will muffle messages produced by a chatty function.\n\nsuppressMessages(library(h2o))\n\n\nIt may be clearer to write: .blue[library(*package*, quietly = TRUE)].\nThis helps with packages that are chatty even when using the quietly = TRUE argument to .blue[library()].\nThis prevents many messages from showing up in R Markdown output without suppressing other critical messages."
  },
  {
    "objectID": "notes/Class3/stringr::word.html",
    "href": "notes/Class3/stringr::word.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: stringr::word\n\n\nNotes:\n#.blue[stringr::word()] .center[.blue[word](*sentence*), start, stop*] + Use this to extract words from a sentence.\n\nwisdom <- \"Caesar salad was created by an Italian in Mexico.\"\nstringr::word(wisdom, 7, 9)\n\n[1] \"Italian in Mexico.\"\n\n\n\nThis is useful for extracting the version of R for publications: stringr::word(R.version.string, 1, 3)"
  },
  {
    "objectID": "notes/Class3/scales::comma.html",
    "href": "notes/Class3/scales::comma.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: scales::comma\n\n\nNotes:\n#.blue[scales::comma()] .center[.blue[scales::comma](*number*)] + It adds commas to number. + For example:\n\nscales::comma(9001)\n\n\nThis is extremely useful when preparing R Markdown reports."
  },
  {
    "objectID": "notes/Class3/%>%.html",
    "href": "notes/Class3/%>%.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: %>%\n\n\nNotes:\n\n\n.blue[%>%]\n.center[ \\(thing_1\\) .blue[%>%]\n\\(thing_2\\)] + The symbol .blue[%>%] is called a pipe. When describing a workflow, it is spoken as “then”. + It sends the output from \\(thing_1\\) to the first argument of \\(thing_2\\).\n\nnrow(medicaldata::covid_testing) %>% \n  scales::comma() %>% \n  print()\n\n\nMany functions can be connected in a pipeline.\nStart code after a pipe on a new line.\nIndent all lines of code two spaces after the first pipe."
  },
  {
    "objectID": "notes/Class3/knitr::opts_chunk$set.html",
    "href": "notes/Class3/knitr::opts_chunk$set.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: knitr::opts_chunk\\(set # Notes: # .blue[`knitr::opts_chunk\\)set()] .center[.blue[knitr::opts_chunk$set](option = value)`]\n\nThis command allows you to set the default behavior for code chunks when knitting\nFor example, this specifies that you want to always show code but never run it\n\n\nknitr::opts_chunk$set(echo=TRUE, eval=FALSE)\n\n\nThis command belongs in the “setup” chunk at the top of an R Markdown script."
  },
  {
    "objectID": "notes/Class3/remotes::install_github.html",
    "href": "notes/Class3/remotes::install_github.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: remotes::install_github\n\n\nNotes:\n#.blue[remotes::install_github()] .center[.blue[remotes::install_github](*author/package*)] + Downloads and install a package from from www.github.com.\n\nremotes::install_github(\"RaymondBalise/rUM\")\n\n\nUse this release to get the latest bug fixes.\nIt checks to see if there is any new content before it downloads.\nYou will need tools to build packages.\n\nThese tools ship with Mac.\nOn Windows you will need to install Rtools"
  },
  {
    "objectID": "notes/Class3/R.Version.html",
    "href": "notes/Class3/R.Version.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: R.Version\n\n\nNotes:\n\n\n.blue[R.Version()]\n.center[.blue[R.Version]()] + .blue[R.Version()] returns a list of details about the version of that is currently running.\n\nR.Version()\n\n.center[.blue[R.version.string]] + .blue[R.version.string] is an easier to work with description of your version of R:\n\nR.version.string\n\n\nThis is useful for extracting the version of R for publications: stringr::word(R.version.string, 1, 3)"
  },
  {
    "objectID": "notes/Class3/paste0.html",
    "href": "notes/Class3/paste0.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: paste0\n\n\nNotes:\n#.blue[paste0()] .center[.blue[paste0](*things*)] .small[ + It pastes together character strings without adding spaces. + The .blue[paste0()] function prints a slash before quotes. .pull-left[\n\npaste0(\"The cyberman\", \" cried.\")\n\n[1] \"The cyberman cried.\"\n\npaste0('The cyberman said \"error.\"')\n\n[1] \"The cyberman said \\\"error.\\\"\"\n\nwords <- \"Hi Mom\"\npaste0(\"Ray said \", '\"', words, '\".')\n\n[1] \"Ray said \\\"Hi Mom\\\".\"\n\n\n] .pull-right[ + The .blue[paste()] function puts a space between words. + The .blue[glue::glue()] function is an excellent alternative.\n\nwords <- \"Hi Mom\"\nglue::glue('Ray said \"{words}\".')\n\nRay said \"Hi Mom\".\n\n\n] ]"
  },
  {
    "objectID": "notes/Class3/conflicted::conflicted_prefer.html",
    "href": "notes/Class3/conflicted::conflicted_prefer.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: conflicted::conflicted_prefer\n\n\nNotes:\n\n\n.blue[conflicted::conflicted_prefer()]\n.small[ .center[.blue[conflicted_prefer](\"*function*\", \"*winning package*\", quiet = TRUE)]] + The conflicted packages complains when the same function name is used in multiple packages. + Use conflicted_prefer() to specify which version should be used by default.\n\nconflict_prefer(\"filter\", \"dplyr\", quiet = TRUE)\n\n\nYou can overwrite this default with package::function()."
  },
  {
    "objectID": "notes/Class3/rUM::make_project\"\".html",
    "href": "notes/Class3/rUM::make_project\"\".html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: rUM::make_project””\n\n\nNotes:\n#.blue[rUM::make_project(\"\")] .center[.blue[make_project](\"*location*\")] + This copies the “shell” for an academic paper into a folder/directory. + For example, this copies the rUM files into the current folder:\n\nrUM::make_project(\"./\")\n\n\nIt is probably easier to use the New Project Wizard from the File menu and choose Research Project Template."
  },
  {
    "objectID": "notes/Class3/nrow.html",
    "href": "notes/Class3/nrow.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: nrow\n\n\nNotes:\n\n\n.blue[nrow()]\n.center[.blue[nrow](*dataset*)] + .blue[nrow()] reports the number of rows/records in a dataset (or matrix).\n\nnrow(mtcars)\n\n[1] 32\n\n\n\nYou will likely use this with .blue[scales::comma()] to include the number of observations in a dataset as part of a report.\n\n\nscales::comma(\n  nrow(medicaldata::covid_testing)\n)\n\n[1] \"15,524\""
  },
  {
    "objectID": "notes/Class3/cat.html",
    "href": "notes/Class3/cat.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: cat\n\n\nNotes:\n\n\n.blue[cat()]\n.center[.blue[cat](*things*)] .pull-left-60[ + .blue[cat()] is simpler version of the .blue[paste()] function. + It does not print the vector position, like [1]. + It does not prints a slash before quotes. + The .blue[glue::glue()] is an excellent alternative.] .pull-right-36[\n\ncat(\"The cyberman\", \"cried.\")\n\nThe cyberman cried.\n\ncat('The cyberman said \"error.\"')\n\nThe cyberman said \"error.\"\n\nwords <- \"Hi Mom\"\ncat(\"Ray said \", '\"', words, '\".')\n\nRay said  \" Hi Mom \".\n\n\n]"
  },
  {
    "objectID": "notes/Class3/<-.html",
    "href": "notes/Class3/<-.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: <-\n\n\nNotes:\n\n\n.blue[<-]\n.center[.blue[*thingy* <- *something*]] + You use .blue[<-] to assign an object (e.g., thingy) a value (e.g., something). + The .blue[<-] operator is pronounced “gets.” + In other languages this would be an =.\n\neverything <- 42\n\n\nUse an .blue[=], not .blue[<-] , to assign values to an argument in a function call.\nYou can also use .blue[->] (e.g., something .blue[->] thingy) but it violates all style guides."
  },
  {
    "objectID": "notes/Class3/mean.html",
    "href": "notes/Class3/mean.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: mean\n\n\nNotes:\n\n\n.blue[mean()]\n.center[.blue[mean](*vector*, na.rm = *value*)] + It calculates an average. + By default it returns NA is any value is missing. + You normally use this on a typical numeric variable but it can be use for other types of data if it can convert them to numbers (like dates/times). + You can also calculate the average on a logical (TRUE/FALSE) variable to get the percent true. Remember: 1=TRUE/YES, 0=FALSE/NO in everything you do. .small[\n\nmean(mtcars$mpg)\n\n[1] 20.09062\n\nmean(TRUE)\n\n[1] 1\n\n\n]"
  },
  {
    "objectID": "notes/Class3/options.html",
    "href": "notes/Class3/options.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: options\n\n\nNotes:\n\n\n.blue[options()]\n.small[ .center[.blue[options](*option* = *value*)]] + The .blue[options()] function sets the global behavior used by R, including how numbers are printed/formatted.\n+ Some packages allow you to set default behavior. + For example, you can turn off messages about how .blue[summarise()] function behaves in .blue[dplyr] with this option:\n\noptions(dplyr.summarise.inform=FALSE)"
  },
  {
    "objectID": "notes/Class4/dplyr::case_when.html",
    "href": "notes/Class4/dplyr::case_when.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: dplyr::case_when\n\n\nNotes:\n\n\n.blue[dplyr::case_when()]\n.small[ .center[.blue[case_when] (*check* ~ *response*, ..., *check* ~ *repsonse*)] + .blue[case_when] does a series of logic checks, in the order listed, and assigns the response from the first check that is true. .pull-left[\n\nlaryngectomy %>%\n  mutate(\n    \\`Pathological Stage` =\n      case_when(\n        path_stg %in% c(1, 2) ~ \"Early\",\n        path_stg %in% c(3, 4) ~ \"Late\",\n        # If you didn't know this value existed...\n        # path_stg == 5 ~ \"Unknown\", \n        .default ~ \"*** PROBLEM ***\"\n      )\n  ) %>%\n  count(\\`Pathological Stage`)\n\n] .pull-right[\n\n\n\n] + .blue[case_when()] often uses TRUE as the last logic check. Because it is always true, it acts like “else” or “otherwise”. + Use .blue[case_when()] instead of .blue[if_else()] if there is any chance the data has unexpected values. ]"
  },
  {
    "objectID": "notes/Class4/dplyr::across.html",
    "href": "notes/Class4/dplyr::across.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: dplyr::across\n\n\nNotes:\n\n\n.blue[dplyr::across()] with .blue[dplyr::mutate()]\n.center[.blue[across](varaibles), function] + The .blue[across()] function with .blue[mutate()] does the same mutation to multiple variables.\n\nlaryngectomy %>% \n  # Convert categorical character variavbles to be factors.\n  mutate(\n    across(gender:sor, factor)\n  ) \n\n\nThe .blue[across()] function is used with .blue[dplyr::summarise] to apply the same summary statistics to many variables."
  },
  {
    "objectID": "notes/Class4/transmute.html",
    "href": "notes/Class4/transmute.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: transmute\n\n\nNotes:\n\n\n.blue[transmute()] only keeps the mutation.\nThis is just way too much typing:\n\nlaryngectomy %>%\n   select(nk_dissection)  %>%\n   mutate(hadND = 2 - nk_dissection)\n\nInstead, just transmute. It will drop all the other variables:\n\nlaryngectomy %>%\n  `transmute(hadND = 2 - nk_dissection)`"
  },
  {
    "objectID": "notes/Class4/group_by.html",
    "href": "notes/Class4/group_by.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: group_by\n\n\nNotes:\n\n\n.blue[group_by()] \\(_1\\)\n.center[.blue[group_by](tableName, groupingVariable)] Before dplyr 1.1 to get groups you would tag the dataset as having a grouping variable:\n\nlaryngectomy %>%\n  select(gender, length_fu) %>% \n  `group_by(gender)` # marks the grouping variable"
  },
  {
    "objectID": "notes/Class4/pivot_wider.html",
    "href": "notes/Class4/pivot_wider.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: pivot_wider\n\n\nNotes:\n\n\n.blue[pivot_wider()] is a thing.\n\nThere is function called pivot_wider() that will take long data and make it wider.\nI rarely use it. Know it exists."
  },
  {
    "objectID": "notes/Class4/tally.html",
    "href": "notes/Class4/tally.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: tally\n\n\nNotes:\n\n\n.blue[tally()]\n.center[.blue[tally](dataset, variable)] It adds up the values: .pull-left-60[\n\nsexVars <- laryngectomy %>%\n  mutate(isMale = 2 - gender ) %>%\n  mutate(sex = as.character(isMale)) %>%\n  mutate(sex = fct_recode(sex, \n                          \"Female\" = \"0\", \n                          \"Male\" = \"1\"))\n  sexVars %>% `tally(gender)`  # adds up 1s and 2s\n  sexVars %>% `tally(isMale)`  # adds up 0s and 1s\n# sexVars %>% tally(sex)  # can't sum up \"Male\" and \"Female\"\n\n] .pull-right-36[\n\n\n\n] ??? This was a good trick… r theTallyTable, eval = FALSE r theTallyTableOut, ref.label=“theTallyTable”, echo=FALSE"
  },
  {
    "objectID": "notes/Class4/summarize.html",
    "href": "notes/Class4/summarize.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: summarize\n\n\nNotes:\n\n\n.blue[summarize()] to make rows/records with statistics. \\(_1\\)\n.small[.center[.blue[summarize](tableName, newName = aggregateFunction)\n.blue[summarize](tableName, aSum = sum(a), anAvg = mean(b), theVar = var(b))] + Make a new dataset with summary statistics + Use it to take a vector and output a single number + Only keeps the new variables + Base aggregate functions + min max mean median quantile sd var IQR diff length sum + dplyr aggregate functions + first last nth n n_distinct .pull-left-60[\n\nlaryngectomy %>%\n{{  summarize(theMinFU = min(length_fu),}}\n{{            theMeanFU = mean(length_fu),}}\n{{            theMaxFU = max(length_fu))}}\n\n] .pull-right-36[\n\n\n\n] ]"
  },
  {
    "objectID": "notes/Class4/mutate.html",
    "href": "notes/Class4/mutate.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: mutate\n\n\nNotes:\n\n\n.blue[mutate()] to Add New Columns/Variables \\(_1\\)\n.center[.bluemutate] The original data used 1 to mean yes and 2 to mean no.\nData should .red[always] use 1 to code yes and 0 to code no. Fix it!\nBinary indicator variables should .red[always] start with a verb.\n\nlaryngectomy %>%  # start with everybody with a laryngectomy then     \n   select(nk_dissection)  `%>%`  # keep only one variable then  \n   `mutate(hadND = 2 - nk_dissection)`  # add a had neck dissection indicator"
  },
  {
    "objectID": "notes/Class4/pull.html",
    "href": "notes/Class4/pull.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: pull\n\n\nNotes:\n\n\n.blue[pull()] makes a vector.\n.center[.blue[pull](tableName, variableName)] Rarely, you will want to pull a column out of a data frame and save it as a vector. .blue[pull()] is the only dplyro verb that does not return a tibble.\n\nyes_no_ND <- laryngectomy %>%\n  mutate(hadND = 2 - nk_dissection) %>% \n  pull(hadND)\n\n.center[]"
  },
  {
    "objectID": "notes/Class4/typeof.html",
    "href": "notes/Class4/typeof.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: typeof\n\n\nNotes:\n\n\n.blue[typeof()]\n.small[ .center[.blue[typeof](*vector*)] .center[.blue[typeof](*dataset$variable*)] + The “type” of an object helps determine what behaviors an object can do.\n+ You can not take the mean of a character variable. + These are the typical types that are used in datasets: .pull-left[ + int = “integer” for numbers without decimals + dbl = “double” for numbers with decimals + lgl = “logical” for true/false + date = “date”] .pull-right[ + chr = “character” for character string + fct = “factor” for categories that are not ordered + ord = “ordered” for ordered categories]\n\ntypeof(pi)\ntypeof(R.version$nickname)\n\n\nOther “types” are used to categorize functions and other complex objects.\nR also uses .blue[mode()] to describe type. It groups “integer” and “double” as “numeric”. ]"
  },
  {
    "objectID": "notes/Class4/dplyr::if_else.html",
    "href": "notes/Class4/dplyr::if_else.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: dplyr::if_else\n\n\nNotes:\n\n\n.blue[dplyr::if_else()]\n.center[.blue[if_else](*check*, *true*, *false*)] + if_else() checks the truth of a logic check on a variable/vector and returns the true argument if it is true or the false argument if it is not true.\n\nlaryngectomy %>%\n  mutate(  # does the initial stage agree with final pathology staging?\n    path_result = if_else(int_stg != path_stg, \"Changed\", \"Same\")\n  ) %>%\n  select(int_stg, path_stg, path_result)\n\n\nThe logic check can involve any number of variables.\n.blue[if_else()] is dangerous because unexpected values can be binned in the false level/group."
  },
  {
    "objectID": "notes/Class4/dplyr::coalesce.html",
    "href": "notes/Class4/dplyr::coalesce.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: dplyr::coalesce\n\n\nNotes:\n\n\n.blue[dplyr::coalesce()]\n.center[.blue[coalesce](varaible(s))] + The .blue[coalesce()] function chooses the first not-missing value from a set of variables.\n\nlaryngectomy %>% \n  # Get day of worst outcome: death, reoccurrence, visit, or huge negative number\n  mutate(\n    outcome_day = coalesce(death_fu, recur_fu, length_fu, -99999999)\n  ) \n\n\nIf you include a huge outlier as the last option, it will make it easy to spot missing values."
  },
  {
    "objectID": "notes/Class4/count.html",
    "href": "notes/Class4/count.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: count\n\n\nNotes:\n\n\n.blue[count()]\n.center[.blue[count](table, variables)] dplyr can do fancy summary statistics but .blue[count()] is quick, easy and useful for frequency counts: .pull-left-60[\n\nlaryngectomy %>%\n  mutate(isMale = 2 - gender ) %>%\n  mutate(sex = as.character(isMale)) %>%\n  mutate(sex = fct_recode(sex, \n                          \"Female\" = \"0\", \n                          \"Male\" = \"1\")) %>% \n  mutate(stage = fct_recode(as.character(int_stg), \n                          \"T1\" = \"1\", \n                          \"T2\" = \"2\",\n                          \"T3\" = \"3\",\n                          \"T4\" = \"4\",\n                          \"Unknown\" = \"5\")) %>% \n  `count(sex, stage)` %>% \n  arrange(sex, stage)  # this just sorts by sex then stage\n\n] .pull-right-36[\n\n\n\n]"
  },
  {
    "objectID": "notes/Class2/suppressMessages.html",
    "href": "notes/Class2/suppressMessages.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: suppressMessages\n\n\nNotes:\n#.blue[suppressMessages()] .center[.blue[suppressMessages](*function*)] + This will muffle messages produced by a chatty function.\n\nsuppressMessages(library(h2o))\n\n\nIt may be clearer to write: .blue[library(*package*, quietly = TRUE)].\nThis helps with packages that are chatty even when using the quietly = TRUE argument to .blue[library()].\nThis prevents many messages from showing up in R Markdown output without suppressing other critical messages."
  },
  {
    "objectID": "notes/Class2/stringr::word.html",
    "href": "notes/Class2/stringr::word.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: stringr::word\n\n\nNotes:\n#.blue[stringr::word()] .center[.blue[word](*sentence*), start, stop*] + Use this to extract words from a sentence.\n\nwisdom <- \"Caesar salad was created by an Italian in Mexico.\"\nstringr::word(wisdom, 7, 9)\n\n[1] \"Italian in Mexico.\"\n\n\n\nThis is useful for extracting the version of R for publications: stringr::word(R.version.string, 1, 3)"
  },
  {
    "objectID": "notes/Class2/scales::comma.html",
    "href": "notes/Class2/scales::comma.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: scales::comma\n\n\nNotes:\n#.blue[scales::comma()] .center[.blue[scales::comma](*number*)] + It adds commas to number. + For example:\n\nscales::comma(9001)\n\n\nThis is extremely useful when preparing R Markdown reports."
  },
  {
    "objectID": "notes/Class2/%>%.html",
    "href": "notes/Class2/%>%.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: %>%\n\n\nNotes:\n\n\n.blue[%>%]\n.center[ \\(thing_1\\) .blue[%>%]\n\\(thing_2\\)] + The symbol .blue[%>%] is called a pipe. When describing a workflow, it is spoken as “then”. + It sends the output from \\(thing_1\\) to the first argument of \\(thing_2\\).\n\nnrow(medicaldata::covid_testing) %>% \n  scales::comma() %>% \n  print()\n\n\nMany functions can be connected in a pipeline.\nStart code after a pipe on a new line.\nIndent all lines of code two spaces after the first pipe."
  },
  {
    "objectID": "notes/Class2/knitr::opts_chunk$set.html",
    "href": "notes/Class2/knitr::opts_chunk$set.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: knitr::opts_chunk\\(set # Notes: # .blue[`knitr::opts_chunk\\)set()] .center[.blue[knitr::opts_chunk$set](option = value)`]\n\nThis command allows you to set the default behavior for code chunks when knitting\nFor example, this specifies that you want to always show code but never run it\n\n\nknitr::opts_chunk$set(echo=TRUE, eval=FALSE)\n\n\nThis command belongs in the “setup” chunk at the top of an R Markdown script."
  },
  {
    "objectID": "notes/Class2/remotes::install_github.html",
    "href": "notes/Class2/remotes::install_github.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: remotes::install_github\n\n\nNotes:\n#.blue[remotes::install_github()] .center[.blue[remotes::install_github](*author/package*)] + Downloads and install a package from from www.github.com.\n\nremotes::install_github(\"RaymondBalise/rUM\")\n\n\nUse this release to get the latest bug fixes.\nIt checks to see if there is any new content before it downloads.\nYou will need tools to build packages.\n\nThese tools ship with Mac.\nOn Windows you will need to install Rtools"
  },
  {
    "objectID": "notes/Class2/R.Version.html",
    "href": "notes/Class2/R.Version.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: R.Version\n\n\nNotes:\n\n\n.blue[R.Version()]\n.center[.blue[R.Version]()] + .blue[R.Version()] returns a list of details about the version of that is currently running.\n\nR.Version()\n\n.center[.blue[R.version.string]] + .blue[R.version.string] is an easier to work with description of your version of R:\n\nR.version.string\n\n\nThis is useful for extracting the version of R for publications: stringr::word(R.version.string, 1, 3)"
  },
  {
    "objectID": "notes/Class2/paste0.html",
    "href": "notes/Class2/paste0.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: paste0\n\n\nNotes:\n#.blue[paste0()] .center[.blue[paste0](*things*)] .small[ + It pastes together character strings without adding spaces. + The .blue[paste0()] function prints a slash before quotes. .pull-left[\n\npaste0(\"The cyberman\", \" cried.\")\n\n[1] \"The cyberman cried.\"\n\npaste0('The cyberman said \"error.\"')\n\n[1] \"The cyberman said \\\"error.\\\"\"\n\nwords <- \"Hi Mom\"\npaste0(\"Ray said \", '\"', words, '\".')\n\n[1] \"Ray said \\\"Hi Mom\\\".\"\n\n\n] .pull-right[ + The .blue[paste()] function puts a space between words. + The .blue[glue::glue()] function is an excellent alternative.\n\nwords <- \"Hi Mom\"\nglue::glue('Ray said \"{words}\".')\n\nRay said \"Hi Mom\".\n\n\n] ]"
  },
  {
    "objectID": "notes/Class2/conflicted::conflicted_prefer.html",
    "href": "notes/Class2/conflicted::conflicted_prefer.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: conflicted::conflicted_prefer\n\n\nNotes:\n\n\n.blue[conflicted::conflicted_prefer()]\n.small[ .center[.blue[conflicted_prefer](\"*function*\", \"*winning package*\", quiet = TRUE)]] + The conflicted packages complains when the same function name is used in multiple packages. + Use conflicted_prefer() to specify which version should be used by default.\n\nconflict_prefer(\"filter\", \"dplyr\", quiet = TRUE)\n\n\nYou can overwrite this default with package::function()."
  },
  {
    "objectID": "notes/Class2/rUM::make_project\"\".html",
    "href": "notes/Class2/rUM::make_project\"\".html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: rUM::make_project””\n\n\nNotes:\n#.blue[rUM::make_project(\"\")] .center[.blue[make_project](\"*location*\")] + This copies the “shell” for an academic paper into a folder/directory. + For example, this copies the rUM files into the current folder:\n\nrUM::make_project(\"./\")\n\n\nIt is probably easier to use the New Project Wizard from the File menu and choose Research Project Template."
  },
  {
    "objectID": "notes/Class2/nrow.html",
    "href": "notes/Class2/nrow.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: nrow\n\n\nNotes:\n\n\n.blue[nrow()]\n.center[.blue[nrow](*dataset*)] + .blue[nrow()] reports the number of rows/records in a dataset (or matrix).\n\nnrow(mtcars)\n\n[1] 32\n\n\n\nYou will likely use this with .blue[scales::comma()] to include the number of observations in a dataset as part of a report.\n\n\nscales::comma(\n  nrow(medicaldata::covid_testing)\n)\n\n[1] \"15,524\""
  },
  {
    "objectID": "notes/Class2/cat.html",
    "href": "notes/Class2/cat.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: cat\n\n\nNotes:\n\n\n.blue[cat()]\n.center[.blue[cat](*things*)] .pull-left-60[ + .blue[cat()] is simpler version of the .blue[paste()] function. + It does not print the vector position, like [1]. + It does not prints a slash before quotes. + The .blue[glue::glue()] is an excellent alternative.] .pull-right-36[\n\ncat(\"The cyberman\", \"cried.\")\n\nThe cyberman cried.\n\ncat('The cyberman said \"error.\"')\n\nThe cyberman said \"error.\"\n\nwords <- \"Hi Mom\"\ncat(\"Ray said \", '\"', words, '\".')\n\nRay said  \" Hi Mom \".\n\n\n]"
  },
  {
    "objectID": "notes/Class2/<-.html",
    "href": "notes/Class2/<-.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: <-\n\n\nNotes:\n\n\n.blue[<-]\n.center[.blue[*thingy* <- *something*]] + You use .blue[<-] to assign an object (e.g., thingy) a value (e.g., something). + The .blue[<-] operator is pronounced “gets.” + In other languages this would be an =.\n\neverything <- 42\n\n\nUse an .blue[=], not .blue[<-] , to assign values to an argument in a function call.\nYou can also use .blue[->] (e.g., something .blue[->] thingy) but it violates all style guides."
  },
  {
    "objectID": "notes/Class2/mean.html",
    "href": "notes/Class2/mean.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: mean\n\n\nNotes:\n\n\n.blue[mean()]\n.center[.blue[mean](*vector*, na.rm = *value*)] + It calculates an average. + By default it returns NA is any value is missing. + You normally use this on a typical numeric variable but it can be use for other types of data if it can convert them to numbers (like dates/times). + You can also calculate the average on a logical (TRUE/FALSE) variable to get the percent true. Remember: 1=TRUE/YES, 0=FALSE/NO in everything you do. .small[\n\nmean(mtcars$mpg)\n\n[1] 20.09062\n\nmean(TRUE)\n\n[1] 1\n\n\n]"
  },
  {
    "objectID": "notes/Class2/options.html",
    "href": "notes/Class2/options.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: options\n\n\nNotes:\n\n\n.blue[options()]\n.small[ .center[.blue[options](*option* = *value*)]] + The .blue[options()] function sets the global behavior used by R, including how numbers are printed/formatted.\n+ Some packages allow you to set default behavior. + For example, you can turn off messages about how .blue[summarise()] function behaves in .blue[dplyr] with this option:\n\noptions(dplyr.summarise.inform=FALSE)"
  },
  {
    "objectID": "notes/Class1/library.html",
    "href": "notes/Class1/library.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: library\n\n\nNotes:\n\n\n.blue[library()]\n.center[.blue[library](*package*)] + The library .blue[library()] function loads a package into working memory (from long term storage on your hard disk drive or solid state drive).\n\nlibrary(survial)\n\n\nThere are a few “meta” packages, like tidymodels and tidyverse, which load many packages from a single .blue[library()] function call. ??? stats::filter and dplyr::filter"
  },
  {
    "objectID": "notes/Class1/dplyr::pull.html",
    "href": "notes/Class1/dplyr::pull.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: dplyr::pull\n\n\nNotes:\n\n\n.blue[dplyr::pull()]\n.center[.blue[pull](*dataset*, *variable*)] + The .blue[pull()] is used to copy of a variable out of a dataset into a new object.\n\npull(mtcars, mpg)\n\n\nWhen it is used with the .blue[filter()] function, .blue[pull()] can be used to extract a single value from a dataset. This is useful when you need to extract a number, like an odds ratio or a p-value, for a report.\n.blue[pull()] is the only .blue[dplyr] function that does not return a tibble."
  },
  {
    "objectID": "notes/Class1/class.html",
    "href": "notes/Class1/class.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: class\n\n\nNotes:\n\n\n.blue[class()]\n.center[.blue[class](_thingy_)] If you are not sure what something is, you can check its class by typing using the .blue[class()] function in the console windowpane. For example, to check the class of the mysterious iris object type this: .pull-left[.center[]] .pull-right[.center[]]"
  },
  {
    "objectID": "notes/Class1/%>%.html",
    "href": "notes/Class1/%>%.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: %>%\n\n\nNotes:\n\n\n.blue[%>%] from the .blue[magrittr] Package\n.center[ \\(thing_1\\) .blue[%>%]\n\\(thing_2\\)] + The symbol .blue[%>%] is called a pipe. When describing a workflow, it is spoken as “then”. + It normally sends the output from \\(thing_1\\) to the first argument of \\(thing_2\\).\n\nmtcars %>% \n  filter(mpg == 30.4) \n\n\nMany functions can be connected in a pipeline.\nStart code after a pipe on a new line.\nIndent all lines of code two spaces after the first pipe."
  },
  {
    "objectID": "notes/Class1/dplyr::filter.html",
    "href": "notes/Class1/dplyr::filter.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: dplyr::filter\n\n\nNotes:\n\n\n.blue[dplyr::filter()]\n.center[.blue[filter](tableName, logical test)] + Use .blue[filter()] to pick rows/records. + Inside the .blue[()] you put a logic check. + .blue[filter()] keeps rows/records where the logic check is true.\n\nfilter(mtcars, am == 0)  # cars with automatic transmission\nfilter(mtcars, is.na(mpg))  # cars missing miles per gallon information\nfilter(mtcars, !is.na(mpg))  # cars not missing miles per gallon information"
  },
  {
    "objectID": "notes/Class1/suppressPackageStartupMessages.html",
    "href": "notes/Class1/suppressPackageStartupMessages.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: suppressPackageStartupMessages\n\n\nNotes:\n\n\n.blue[suppressPackageStartupMessages()]\n.center[.blue[suppressPackageStartupMessages](library(*package*))] + Load a package without printing its greeting message.\n\nsuppressPackageStartupMessages(library(tidyverse))\n\n\nThis is very useful with the .blue[tidyverse] and .blue[tidymodels]. Use this if and only if you are also using the .blue[conflicted] package (to avoid function name conflicts)."
  },
  {
    "objectID": "notes/Class1/rm.html",
    "href": "notes/Class1/rm.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: rm\n\n\nNotes:\n\n\n.blue[rm()]\n.center[.blue[rm](*things*)] + The .blue[rm()] function removes an object from R’s working memory.\n\nlife_the_universe_and_everything <- 42\nrm(life_the_universe_and_everything)"
  },
  {
    "objectID": "notes/Class1/remotes::install_cran.html",
    "href": "notes/Class1/remotes::install_cran.html",
    "title": "BST623 functions",
    "section": "",
    "text": "Function name: remotes::install_cran\n\n\nNotes:\n\n\n.blue[remotes::install_cran()]\nA better way to add packages is to use the .blue[install_cran()] function from the .blue[remotes] package: .center[.blue[remotes::install\\_cran](\"*thingy*\")] For example to install the “DOPE” package:\n\nremotes::install_cran(\"DOPE\")\n\nPaste that line into the Console windowpane (bottom left corner) and tap the return or enter key on your keyboard. It will check to see the package has been updated before it bothers to do the download."
  }
]