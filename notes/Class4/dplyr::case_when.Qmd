# Function name: dplyr::case_when
# Notes:
# .blue[`dplyr::case_when()`]
.small[
.center[.blue[`case_when`] (`*check* ~ *response*, ..., *check* ~ *repsonse*`)]
+ .blue[`case_when`] does a series of logic checks, in the order listed, and assigns the response from the first check that is true.
.pull-left[
```{r eval=FALSE}
laryngectomy %>%
  mutate(
    \`Pathological Stage` =
      case_when(
        path_stg %in% c(1, 2) ~ "Early",
        path_stg %in% c(3, 4) ~ "Late",
        # If you didn't know this value existed...
        # path_stg == 5 ~ "Unknown", 
        .default ~ "*** PROBLEM ***"
      )
  ) %>%
  count(\`Pathological Stage`)
```
]
.pull-right[
```{r eval=FALSE, echo=FALSE}
laryngectomy %>%
  mutate(
    `Pathological Stage` =
      case_when(
        path_stg %in% c(1, 2) ~ "Early",
        path_stg %in% c(3, 4) ~ "Late",
        # If you didn't know this value existed...
        # path_stg == 5 ~ "Unknown", 
        TRUE ~ "*** PROBLEM ***"
      )
  ) %>%
  count(`Pathological Stage`)
```
]
+ .blue[`case_when()`] often uses `TRUE` as the last logic check.  Because it is always true, it acts like "else" or "otherwise". 
+ Use .blue[`case_when()`] instead of .blue[`if_else()`] if there is *any* chance the data has unexpected values.
]
---